{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"anguilla","text":""},{"location":"#anguilla","title":"anguilla","text":"<p><code>anguilla</code> is a mapping and interactive machine learning package for digital musical instrument design in Python.</p> <p>This is an early stage project. Currently, the main interface is the <code>IML</code> class, which allows adding input-output pairs (<code>IML.add</code>) and subsequently mapping points in the input space to outputs (<code>IML.map</code>). </p> <p><code>anguilla</code> is designed to be modular and hackable. An <code>IML</code> object is composed of several exchangeable parts:</p> <ul> <li>an <code>Embedding</code> embeds input points into a feature space</li> <li>an <code>NNSearch</code> implements nearest-neighbor search in the feature space</li> <li>an <code>Interpolate</code> combines a set of output points using the distances of their corresponding input points from a neighboring query point.</li> </ul> <p><code>python -m anguilla server</code> will expose the Python API over Open Sound Control (OSC) using iipyper.</p> <p>For examples and tutorials of how to use <code>anguilla</code>, see our examples repo (TBC).</p>"},{"location":"#install","title":"Install","text":"<p><code>anguilla</code> can be installed via PyPI:</p> <pre><code>pip install anguilla\n</code></pre>"},{"location":"#develop","title":"Develop","text":"<p>See the iil-dev repo for a recommended dev environment. </p> <p>It's also possible to develop <code>anguilla</code> in isolation. You will need Poetry and your Python environment manager of choice. With <code>conda</code>, for example:</p> <pre><code>conda create -n anguilla-env python=3.10 poetry\nconda activate anguilla-env\n</code></pre> <p>then:</p> <pre><code>git clone git@github.com:Intelligent-Instruments-Lab/anguilla.git\ncd anguilla\npoetry install\n</code></pre>"},{"location":"#contact","title":"Contact","text":"<p><code>anguilla</code> is developed by the Intelligent Instruments Lab. Get in touch to collaborate:</p> <p>\u25e6 iil.is \u25e6  Facebook \u25e6  Instagram \u25e6  X (Twitter) \u25e6  YouTube \u25e6  Discord \u25e6  GitHub \u25e6  LinkedIn \u25e6  Email \u25e6 </p>"},{"location":"#funding","title":"Funding","text":"<p>The Intelligent Instruments project (INTENT) is funded by the European Research Council (ERC) under the European Union\u2019s Horizon 2020 research and innovation programme (Grant agreement No. 101001848).</p>"},{"location":"reference/anguilla/__init__/","title":"init","text":""},{"location":"reference/anguilla/__init__/#anguilla.IML","title":"<code>IML</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>class IML(serialize.JSONSerializable):\n\n    def __init__(self, \n            emb:Union[str,embed.Embedding]=None, \n            interp:Union[str,interpolate.Interpolate]=None,\n            index:nnsearch.Index=None,\n            k:int=10,\n            verbose=False):\n        \"\"\"\n        Args:\n            embed: instance, type or name of Feature subclass (defaults to Identity)\n            interp: instance, type or name of Interpolate subclass (defaults to Smooth)\n            index: instance of Index (defaults to IndexBrute)\n            k: default k-nearest neighbors (can be overridden later)\n        \"\"\"\n        self.verbose = verbose\n        # Feature converts Inputs to Features\n        if emb is None:\n            emb = embed.Identity()\n        elif isinstance(emb, str):\n            emb = getattr(embed, emb)()\n        elif isinstance(emb, type) and issubclass(emb, embed.Embedding):\n            emb = emb()\n        elif isinstance(emb, embed.Embedding):\n            pass\n        else:\n            raise ValueError\n\n         # Interpolate combines a set of Outputs according to their Scores\n        if interp is None:\n            interp = interpolate.Smooth()\n        elif isinstance(interp, str):\n            interp = getattr(interpolate, interp)()\n        elif isinstance(interp, type) and issubclass(interp, interpolate.Interpolate):\n            interp = interp()\n        elif isinstance(interp, interpolate.Interpolate):\n            pass\n        else:\n            raise ValueError\n\n        # Index determines the distance metric and efficiency\n        if index is None:\n            index = nnsearch.IndexBrute(emb.size)\n        elif isinstance(index, str):\n            index = getattr(nnsearch, index)()\n        elif isinstance(index, type) and issubclass(index, nnsearch.Index):\n            index = index(emb.size)\n        elif isinstance(index, nnsearch.Index):\n            pass\n        else:\n            raise ValueError\n\n        super().__init__(\n            emb=emb, interp=interp, index=index,\n            k=k)\n\n        self.interpolate = interp\n        self.embed = emb\n        self.neighbors = nnsearch.NNSearch(index, k=k)\n        self.reset()\n\n    def reset(self, keep_near:Input=None, k:int=None):\n        \"\"\"\n        delete all data\n\n        Args:\n            keep_near: don't remove the neighbors of this input\n            k: number of neighbors for above\n        \"\"\"\n        print('reset')\n        res = None\n        if keep_near is not None and len(self.pairs)&gt;0:\n            if len(keep_near)!=len(self.pairs[0][0]):\n                print('ERROR: iml: keep_near should be an Input vector')\n                keep_near = None\n            else:\n                print('searching neighbors for keep_near')\n                res = self.search(keep_near, k=k)\n\n        self.pairs: Dict[PairID, IOPair] = {}\n        # NNSearch converts feature to output IDs and scores\n        self.neighbors.reset()\n\n        if res is not None:\n            print(f'restoring {len(res.ids)} neighbors')\n            for id,inp,out in zip(res.ids, res.inputs, res.outputs):\n                self.add(inp,out,id=id)\n\n    def embed_batch(self, inputs:List[Input]):\n        if self.embed.is_batched:\n            return self.embed(inputs)\n        else:\n            return [self.embed(input) for input in inputs]\n\n    def add_batch(self,\n            inputs: List[Input], \n            outputs: List[Output], \n            ids: Optional[PairIDs]=None,\n            ) -&gt; PairIDs:\n        \"\"\"\n        Add a batch of data points to the mapping.\n\n        Args:\n            input: list of inputs or ndarray with leading batch dimension\n            output:  list of inputs or ndarray with leading batch dimension \n            id: list of PairIDs to use.\n                if any are an existing id, replace those points.\n                if not supplied, ids will be chosen automatically.\n\n        Returns:\n            ids: ids of the new data points if you need to reference them later\n        \"\"\"\n        features = self.embed_batch(inputs)\n\n        # TODO: batched `neighbors.add`\n        new_ids = []\n        if ids is None:\n            ids = it.repeat(None)\n        for input, feature, id, output in zip(inputs, features, ids, outputs):\n            id = self.neighbors.add(feature, id)\n            self.pairs[id] = IOPair(input, output)\n            new_ids.append(id)\n\n        return new_ids\n\n    def add(self, \n            input: Input, \n            output: Output, \n            id: Optional[PairID]=None,\n            batch: bool=False\n            ) -&gt; PairID:\n        \"\"\"\n        Add a data point to the mapping.\n\n        Args:\n            input: Input item\n            output: Output item\n            id: PairID to use; if an existing id, replace the point.\n                if not supplied, id will be chosen automatically.\n            batch: if True, equivalent to `add_batch`\n\n        Returns:\n            id: id of the new data point if you need to reference it later\n        \"\"\"\n        if batch:\n            return self.add_batch(input, output, id)\n        else:\n            return self.add_batch((input,), (output,), (id,))[0]\n        # if not isinstance(id, str) and hasattr(id, '__len__'):\n        #     # refuse any id which is a non-string sequence\n        #     # sequences are used for batches of ids\n        #     raise ValueError(\"can't use object with __len__ as a PairID\")\n        # if self.verbose: print(f'add {input=}, {output=}')\n        # feature = self.embed(input)\n        # id = self.neighbors.add(feature, id)\n        # # track the mapping from output IDs back to outputs\n        # self.pairs[id] = IOPair(input, output)\n        # return id\n\n    def get(self, id:PairID) -&gt; IOPair:\n        \"\"\"\n        look up an Input/Output pair by ID\n\n        Args:\n            ids: ID to look up.\n        \"\"\"\n        try:\n            return self.pairs[id]\n        except Exception:\n            print(\"NNSearch: WARNING: can't `get` ID which doesn't exist or has been removed\")\n\n    def remove_batch(self, ids:PairIDs):\n        self.remove(ids, batch=True)\n\n    def remove(self, id:PairID, batch:bool=None):\n        \"\"\"\n        Remove from mapping by ID(s)\n\n        Args:\n            ids: ID or collection of IDs of points to remove from the mapping.\n            batch: True if removing a batch of ids, False if a single id.\n                will attempt to infer from `id` if not supplied.\n        \"\"\"\n        if batch is None:\n            batch = not isinstance(id, str) and hasattr(id, '__len__')\n\n        if not batch:\n            ids = (id,)\n        for i in ids:\n            try:    \n                del self.pairs[i]\n            except Exception:\n                print(f\"IML: WARNING: can't `remove` ID {i} which doesn't exist or has already been removed\")\n\n        self.neighbors.remove(id, batch=batch)\n\n    def remove_near(self, input:Input, k:int=None) -&gt; PairIDs:\n        \"\"\"\n        Remove from mapping by proximity to Input.\n        \"\"\"\n        feature = self.embed(input)\n        return self.neighbors.remove_near(feature, k=k)\n\n    def search_batch(self, inputs:List[Input], k:int=None, from_map=False) -&gt; SearchResult:\n        \"\"\"\n        find k-nearest neighbors for each batch item\n\n        Args:\n            input: input item\n            k: max number of neighbors\n            from_map: if True, skip collating inputs and ids and set them to None \n\n        Returns:\n            inputs: neighboring Inputs\n            outputs: corresponding Outputs\n            ids: ids of Input/Output pairs\n            scores: dissimilarity Scores\n\n        Note: neighbor dimension is first\n        \"\"\"\n        features = self.embed_batch(inputs)\n\n        if self.neighbors.index.is_batched:\n            ids_batch, scores_batch = self.neighbors(features, k=k)\n        else:\n            # index does not support batching case\n            ids_batch = []\n            scores_batch = []\n            for feature in features:\n                ids, scores = self.neighbors(feature, k=k)\n                ids_batch.append(ids)\n                scores_batch.append(scores)\n\n        inputs_batch = []\n        outputs_batch = []\n\n        # get i/o pairs from ids\n        # NOTE: bottleneck is here for `map` on large batches\n        for feature, ids, scores in zip(features, ids_batch, scores_batch):\n            # handle case where there are fewer than k neighbors\n            if not len(ids):\n                raise RuntimeError('no points in mapping. add some!')\n\n            # inputs, outputs = zip(*(self.pairs[i] for i in ids))\n            outputs_batch.append([self.pairs[i].output for i in ids])\n            if not from_map:\n                inputs_batch.append([self.pairs[i].input for i in ids])\n\n        # neighbor dimension goes first\n        if from_map:\n            inputs, ids = None, None\n        else:\n            inputs = np.stack(inputs_batch, 1)\n            ids = np.stack(ids_batch, 1)\n        outputs = np.stack(outputs_batch, 1)\n        scores = np.stack(scores_batch, 1)\n\n        return SearchResult(inputs, outputs, ids, scores)\n\n    def search(self, input:Input, k:int=None) -&gt; SearchResult:\n        \"\"\"\n        find k-nearest neighbors\n\n        Args:\n            input: input item\n            k: max number of neighbors\n\n        Returns:\n            inputs: neighboring Inputs\n            outputs: corresponding Outputs\n            ids: ids of Input/Output pairs\n            scores: dissimilarity Scores\n        \"\"\"\n        feature = self.embed(input)\n        ids, scores = self.neighbors(feature, k=k)\n        # handle case where there are fewer than k neighbors\n        if not len(ids):\n            raise RuntimeError('no points in mapping. add some!')\n\n        inputs, outputs = zip(*(self.pairs[i] for i in ids))\n\n        # TODO: text-mode visualize scores\n        # s = ' '*len(self.pairs)\n\n        return SearchResult(inputs, outputs, ids, scores)\n\n    def map_batch(self, inputs:List[Input], k:int=None, **kw):\n        \"\"\"convert a batch of Input to batch of Output using search + interpolate\n\n        Args:\n            input: [batch x ...]\n            k: max neighbors\n            **kw: additional arguments are passed to interpolate\n\n        Returns:\n            output instance\n        \"\"\"\n        _, outputs, _, scores = self.search_batch(inputs, k, from_map=True)\n        return self.interpolate(outputs, scores, **kw)\n\n    def map(self, input:Input, k:int=None, **kw) -&gt; Output:\n        \"\"\"convert an Input to an Output using search + interpolate\n\n        Args:\n            input: input\n            k: max neighbors\n            **kw: additional arguments are passed to interpolate\n\n        Returns:\n            output instance\n        \"\"\"\n        # print(f'map {input=}')\n        _, outputs, _, scores = self.search(input, k)\n        return self.interpolate(outputs, scores, **kw)\n\n    def save_state(self):\n        \"\"\"\n        return dataset from this IML object.\n\n        Returns:\n            state: data in this IML object\n        \"\"\"\n        return {\n            'pairs': self.pairs\n        }\n\n    def load_state(self, state):\n        \"\"\"\n        load dataset into this IML object.\n\n        Args:\n            state: data as obtained from `save_state`\n        \"\"\"\n        for id,pair in state['pairs'].items():\n            self.add(*pair, id=PairID(id))        \n\n    def save(self, path:str):\n        \"\"\"\n        serialize the whole IML object to JSON\n\n        Args:\n            path: path to JSON file\n        \"\"\"\n        serialize.save(path, self)\n\n    @classmethod\n    def load(cls, path):\n        \"\"\"\n        deserialize a new IML object from JSON\n\n        Args:\n            path: path to JSON file\n\n        Returns:\n            new IML instance\n        \"\"\"\n        inst = serialize.load(path)\n        assert isinstance(inst, cls), type(inst)\n        return inst\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.__init__","title":"<code>__init__(emb=None, interp=None, index=None, k=10, verbose=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>embed</code> <p>instance, type or name of Feature subclass (defaults to Identity)</p> required <code>interp</code> <code>Union[str, Interpolate]</code> <p>instance, type or name of Interpolate subclass (defaults to Smooth)</p> <code>None</code> <code>index</code> <code>Index</code> <p>instance of Index (defaults to IndexBrute)</p> <code>None</code> <code>k</code> <code>int</code> <p>default k-nearest neighbors (can be overridden later)</p> <code>10</code> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def __init__(self, \n        emb:Union[str,embed.Embedding]=None, \n        interp:Union[str,interpolate.Interpolate]=None,\n        index:nnsearch.Index=None,\n        k:int=10,\n        verbose=False):\n    \"\"\"\n    Args:\n        embed: instance, type or name of Feature subclass (defaults to Identity)\n        interp: instance, type or name of Interpolate subclass (defaults to Smooth)\n        index: instance of Index (defaults to IndexBrute)\n        k: default k-nearest neighbors (can be overridden later)\n    \"\"\"\n    self.verbose = verbose\n    # Feature converts Inputs to Features\n    if emb is None:\n        emb = embed.Identity()\n    elif isinstance(emb, str):\n        emb = getattr(embed, emb)()\n    elif isinstance(emb, type) and issubclass(emb, embed.Embedding):\n        emb = emb()\n    elif isinstance(emb, embed.Embedding):\n        pass\n    else:\n        raise ValueError\n\n     # Interpolate combines a set of Outputs according to their Scores\n    if interp is None:\n        interp = interpolate.Smooth()\n    elif isinstance(interp, str):\n        interp = getattr(interpolate, interp)()\n    elif isinstance(interp, type) and issubclass(interp, interpolate.Interpolate):\n        interp = interp()\n    elif isinstance(interp, interpolate.Interpolate):\n        pass\n    else:\n        raise ValueError\n\n    # Index determines the distance metric and efficiency\n    if index is None:\n        index = nnsearch.IndexBrute(emb.size)\n    elif isinstance(index, str):\n        index = getattr(nnsearch, index)()\n    elif isinstance(index, type) and issubclass(index, nnsearch.Index):\n        index = index(emb.size)\n    elif isinstance(index, nnsearch.Index):\n        pass\n    else:\n        raise ValueError\n\n    super().__init__(\n        emb=emb, interp=interp, index=index,\n        k=k)\n\n    self.interpolate = interp\n    self.embed = emb\n    self.neighbors = nnsearch.NNSearch(index, k=k)\n    self.reset()\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.add","title":"<code>add(input, output, id=None, batch=False)</code>","text":"<p>Add a data point to the mapping.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Input</code> <p>Input item</p> required <code>output</code> <code>Output</code> <p>Output item</p> required <code>id</code> <code>Optional[PairID]</code> <p>PairID to use; if an existing id, replace the point. if not supplied, id will be chosen automatically.</p> <code>None</code> <code>batch</code> <code>bool</code> <p>if True, equivalent to <code>add_batch</code></p> <code>False</code> <p>Returns:</p> Name Type Description <code>id</code> <code>PairID</code> <p>id of the new data point if you need to reference it later</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def add(self, \n        input: Input, \n        output: Output, \n        id: Optional[PairID]=None,\n        batch: bool=False\n        ) -&gt; PairID:\n    \"\"\"\n    Add a data point to the mapping.\n\n    Args:\n        input: Input item\n        output: Output item\n        id: PairID to use; if an existing id, replace the point.\n            if not supplied, id will be chosen automatically.\n        batch: if True, equivalent to `add_batch`\n\n    Returns:\n        id: id of the new data point if you need to reference it later\n    \"\"\"\n    if batch:\n        return self.add_batch(input, output, id)\n    else:\n        return self.add_batch((input,), (output,), (id,))[0]\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.add_batch","title":"<code>add_batch(inputs, outputs, ids=None)</code>","text":"<p>Add a batch of data points to the mapping.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>list of inputs or ndarray with leading batch dimension</p> required <code>output</code> <p>list of inputs or ndarray with leading batch dimension </p> required <code>id</code> <p>list of PairIDs to use. if any are an existing id, replace those points. if not supplied, ids will be chosen automatically.</p> required <p>Returns:</p> Name Type Description <code>ids</code> <code>PairIDs</code> <p>ids of the new data points if you need to reference them later</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def add_batch(self,\n        inputs: List[Input], \n        outputs: List[Output], \n        ids: Optional[PairIDs]=None,\n        ) -&gt; PairIDs:\n    \"\"\"\n    Add a batch of data points to the mapping.\n\n    Args:\n        input: list of inputs or ndarray with leading batch dimension\n        output:  list of inputs or ndarray with leading batch dimension \n        id: list of PairIDs to use.\n            if any are an existing id, replace those points.\n            if not supplied, ids will be chosen automatically.\n\n    Returns:\n        ids: ids of the new data points if you need to reference them later\n    \"\"\"\n    features = self.embed_batch(inputs)\n\n    # TODO: batched `neighbors.add`\n    new_ids = []\n    if ids is None:\n        ids = it.repeat(None)\n    for input, feature, id, output in zip(inputs, features, ids, outputs):\n        id = self.neighbors.add(feature, id)\n        self.pairs[id] = IOPair(input, output)\n        new_ids.append(id)\n\n    return new_ids\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.get","title":"<code>get(id)</code>","text":"<p>look up an Input/Output pair by ID</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <p>ID to look up.</p> required Source code in <code>src/anguilla/__init__.py</code> <pre><code>def get(self, id:PairID) -&gt; IOPair:\n    \"\"\"\n    look up an Input/Output pair by ID\n\n    Args:\n        ids: ID to look up.\n    \"\"\"\n    try:\n        return self.pairs[id]\n    except Exception:\n        print(\"NNSearch: WARNING: can't `get` ID which doesn't exist or has been removed\")\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>deserialize a new IML object from JSON</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>path to JSON file</p> required <p>Returns:</p> Type Description <p>new IML instance</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>@classmethod\ndef load(cls, path):\n    \"\"\"\n    deserialize a new IML object from JSON\n\n    Args:\n        path: path to JSON file\n\n    Returns:\n        new IML instance\n    \"\"\"\n    inst = serialize.load(path)\n    assert isinstance(inst, cls), type(inst)\n    return inst\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.load_state","title":"<code>load_state(state)</code>","text":"<p>load dataset into this IML object.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>data as obtained from <code>save_state</code></p> required Source code in <code>src/anguilla/__init__.py</code> <pre><code>def load_state(self, state):\n    \"\"\"\n    load dataset into this IML object.\n\n    Args:\n        state: data as obtained from `save_state`\n    \"\"\"\n    for id,pair in state['pairs'].items():\n        self.add(*pair, id=PairID(id))        \n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.map","title":"<code>map(input, k=None, **kw)</code>","text":"<p>convert an Input to an Output using search + interpolate</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Input</code> <p>input</p> required <code>k</code> <code>int</code> <p>max neighbors</p> <code>None</code> <code>**kw</code> <p>additional arguments are passed to interpolate</p> <code>{}</code> <p>Returns:</p> Type Description <code>Output</code> <p>output instance</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def map(self, input:Input, k:int=None, **kw) -&gt; Output:\n    \"\"\"convert an Input to an Output using search + interpolate\n\n    Args:\n        input: input\n        k: max neighbors\n        **kw: additional arguments are passed to interpolate\n\n    Returns:\n        output instance\n    \"\"\"\n    # print(f'map {input=}')\n    _, outputs, _, scores = self.search(input, k)\n    return self.interpolate(outputs, scores, **kw)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.map_batch","title":"<code>map_batch(inputs, k=None, **kw)</code>","text":"<p>convert a batch of Input to batch of Output using search + interpolate</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>[batch x ...]</p> required <code>k</code> <code>int</code> <p>max neighbors</p> <code>None</code> <code>**kw</code> <p>additional arguments are passed to interpolate</p> <code>{}</code> <p>Returns:</p> Type Description <p>output instance</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def map_batch(self, inputs:List[Input], k:int=None, **kw):\n    \"\"\"convert a batch of Input to batch of Output using search + interpolate\n\n    Args:\n        input: [batch x ...]\n        k: max neighbors\n        **kw: additional arguments are passed to interpolate\n\n    Returns:\n        output instance\n    \"\"\"\n    _, outputs, _, scores = self.search_batch(inputs, k, from_map=True)\n    return self.interpolate(outputs, scores, **kw)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.remove","title":"<code>remove(id, batch=None)</code>","text":"<p>Remove from mapping by ID(s)</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <p>ID or collection of IDs of points to remove from the mapping.</p> required <code>batch</code> <code>bool</code> <p>True if removing a batch of ids, False if a single id. will attempt to infer from <code>id</code> if not supplied.</p> <code>None</code> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def remove(self, id:PairID, batch:bool=None):\n    \"\"\"\n    Remove from mapping by ID(s)\n\n    Args:\n        ids: ID or collection of IDs of points to remove from the mapping.\n        batch: True if removing a batch of ids, False if a single id.\n            will attempt to infer from `id` if not supplied.\n    \"\"\"\n    if batch is None:\n        batch = not isinstance(id, str) and hasattr(id, '__len__')\n\n    if not batch:\n        ids = (id,)\n    for i in ids:\n        try:    \n            del self.pairs[i]\n        except Exception:\n            print(f\"IML: WARNING: can't `remove` ID {i} which doesn't exist or has already been removed\")\n\n    self.neighbors.remove(id, batch=batch)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.remove_near","title":"<code>remove_near(input, k=None)</code>","text":"<p>Remove from mapping by proximity to Input.</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def remove_near(self, input:Input, k:int=None) -&gt; PairIDs:\n    \"\"\"\n    Remove from mapping by proximity to Input.\n    \"\"\"\n    feature = self.embed(input)\n    return self.neighbors.remove_near(feature, k=k)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.reset","title":"<code>reset(keep_near=None, k=None)</code>","text":"<p>delete all data</p> <p>Parameters:</p> Name Type Description Default <code>keep_near</code> <code>Input</code> <p>don't remove the neighbors of this input</p> <code>None</code> <code>k</code> <code>int</code> <p>number of neighbors for above</p> <code>None</code> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def reset(self, keep_near:Input=None, k:int=None):\n    \"\"\"\n    delete all data\n\n    Args:\n        keep_near: don't remove the neighbors of this input\n        k: number of neighbors for above\n    \"\"\"\n    print('reset')\n    res = None\n    if keep_near is not None and len(self.pairs)&gt;0:\n        if len(keep_near)!=len(self.pairs[0][0]):\n            print('ERROR: iml: keep_near should be an Input vector')\n            keep_near = None\n        else:\n            print('searching neighbors for keep_near')\n            res = self.search(keep_near, k=k)\n\n    self.pairs: Dict[PairID, IOPair] = {}\n    # NNSearch converts feature to output IDs and scores\n    self.neighbors.reset()\n\n    if res is not None:\n        print(f'restoring {len(res.ids)} neighbors')\n        for id,inp,out in zip(res.ids, res.inputs, res.outputs):\n            self.add(inp,out,id=id)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.save","title":"<code>save(path)</code>","text":"<p>serialize the whole IML object to JSON</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to JSON file</p> required Source code in <code>src/anguilla/__init__.py</code> <pre><code>def save(self, path:str):\n    \"\"\"\n    serialize the whole IML object to JSON\n\n    Args:\n        path: path to JSON file\n    \"\"\"\n    serialize.save(path, self)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.save_state","title":"<code>save_state()</code>","text":"<p>return dataset from this IML object.</p> <p>Returns:</p> Name Type Description <code>state</code> <p>data in this IML object</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def save_state(self):\n    \"\"\"\n    return dataset from this IML object.\n\n    Returns:\n        state: data in this IML object\n    \"\"\"\n    return {\n        'pairs': self.pairs\n    }\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.search","title":"<code>search(input, k=None)</code>","text":"<p>find k-nearest neighbors</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Input</code> <p>input item</p> required <code>k</code> <code>int</code> <p>max number of neighbors</p> <code>None</code> <p>Returns:</p> Name Type Description <code>inputs</code> <code>SearchResult</code> <p>neighboring Inputs</p> <code>outputs</code> <code>SearchResult</code> <p>corresponding Outputs</p> <code>ids</code> <code>SearchResult</code> <p>ids of Input/Output pairs</p> <code>scores</code> <code>SearchResult</code> <p>dissimilarity Scores</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def search(self, input:Input, k:int=None) -&gt; SearchResult:\n    \"\"\"\n    find k-nearest neighbors\n\n    Args:\n        input: input item\n        k: max number of neighbors\n\n    Returns:\n        inputs: neighboring Inputs\n        outputs: corresponding Outputs\n        ids: ids of Input/Output pairs\n        scores: dissimilarity Scores\n    \"\"\"\n    feature = self.embed(input)\n    ids, scores = self.neighbors(feature, k=k)\n    # handle case where there are fewer than k neighbors\n    if not len(ids):\n        raise RuntimeError('no points in mapping. add some!')\n\n    inputs, outputs = zip(*(self.pairs[i] for i in ids))\n\n    # TODO: text-mode visualize scores\n    # s = ' '*len(self.pairs)\n\n    return SearchResult(inputs, outputs, ids, scores)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.search_batch","title":"<code>search_batch(inputs, k=None, from_map=False)</code>","text":"<p>find k-nearest neighbors for each batch item</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>input item</p> required <code>k</code> <code>int</code> <p>max number of neighbors</p> <code>None</code> <code>from_map</code> <p>if True, skip collating inputs and ids and set them to None </p> <code>False</code> <p>Returns:</p> Name Type Description <code>inputs</code> <code>SearchResult</code> <p>neighboring Inputs</p> <code>outputs</code> <code>SearchResult</code> <p>corresponding Outputs</p> <code>ids</code> <code>SearchResult</code> <p>ids of Input/Output pairs</p> <code>scores</code> <code>SearchResult</code> <p>dissimilarity Scores</p> <p>Note: neighbor dimension is first</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def search_batch(self, inputs:List[Input], k:int=None, from_map=False) -&gt; SearchResult:\n    \"\"\"\n    find k-nearest neighbors for each batch item\n\n    Args:\n        input: input item\n        k: max number of neighbors\n        from_map: if True, skip collating inputs and ids and set them to None \n\n    Returns:\n        inputs: neighboring Inputs\n        outputs: corresponding Outputs\n        ids: ids of Input/Output pairs\n        scores: dissimilarity Scores\n\n    Note: neighbor dimension is first\n    \"\"\"\n    features = self.embed_batch(inputs)\n\n    if self.neighbors.index.is_batched:\n        ids_batch, scores_batch = self.neighbors(features, k=k)\n    else:\n        # index does not support batching case\n        ids_batch = []\n        scores_batch = []\n        for feature in features:\n            ids, scores = self.neighbors(feature, k=k)\n            ids_batch.append(ids)\n            scores_batch.append(scores)\n\n    inputs_batch = []\n    outputs_batch = []\n\n    # get i/o pairs from ids\n    # NOTE: bottleneck is here for `map` on large batches\n    for feature, ids, scores in zip(features, ids_batch, scores_batch):\n        # handle case where there are fewer than k neighbors\n        if not len(ids):\n            raise RuntimeError('no points in mapping. add some!')\n\n        # inputs, outputs = zip(*(self.pairs[i] for i in ids))\n        outputs_batch.append([self.pairs[i].output for i in ids])\n        if not from_map:\n            inputs_batch.append([self.pairs[i].input for i in ids])\n\n    # neighbor dimension goes first\n    if from_map:\n        inputs, ids = None, None\n    else:\n        inputs = np.stack(inputs_batch, 1)\n        ids = np.stack(ids_batch, 1)\n    outputs = np.stack(outputs_batch, 1)\n    scores = np.stack(scores_batch, 1)\n\n    return SearchResult(inputs, outputs, ids, scores)\n</code></pre>"},{"location":"reference/anguilla/embed/","title":"Embed","text":""},{"location":"reference/anguilla/embed/#anguilla.embed.Cat","title":"<code>Cat</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>Embedding which applies multiple other embeddings to elements of a sequence, and concatenates the results</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class Cat(Embedding):\n    \"\"\"\n    Embedding which applies multiple other embeddings to elements of a sequence,\n    and concatenates the results\n    \"\"\"\n    def __init__(self, *embs):\n        self.embs = embs\n    def __call__(self, sources):\n        assert len(sources)==len(self.embs)\n        parts = [emb(source) for source, emb in zip(sources, self.embs)]\n        # convert 0d scalars to 1d before cat\n        parts = [p[None] if p.ndim==0 else p for p in parts]\n        return np.concatenate(parts, -1)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Chain","title":"<code>Chain</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>Embedding which applies multiple embeddings in series to the same input</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class Chain(Embedding):\n    \"\"\"\n    Embedding which applies multiple embeddings in series to the same input\n    \"\"\"\n    def __init__(self, *embs):\n        self.embs = embs\n    def __call__(self, source):\n        for emb in self.embs:\n            source = emb(source)\n        return source\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Identity","title":"<code>Identity</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>The most basic Embedding.  Optionally checks size of input vector and ensures it is a numpy array,  but otherwise leaves it unchanged.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class Identity(Embedding):\n    \"\"\"\n    The most basic Embedding. \n    Optionally checks size of input vector and ensures it is a numpy array, \n    but otherwise leaves it unchanged.\n    \"\"\"\n    def __init__(self, size:Optional[int]=None):\n        \"\"\"\n        Args:\n            size: both the Input and the Feature size.\n                if supplied, inputs will be validated to be that size.\n                otherwise, they will just be converted to ndarrays.\n        \"\"\"\n        super().__init__(size=size)\n        self.size = self.input_size = size\n        self.is_batched = True\n\n    def __call__(self, source) -&gt; ArrayLike:\n        \"\"\"\n        embed the input.\n\n        Args:\n            source: an input sequence\n\n        Returns:\n            feature: the input sequence as a numpy array.\n        \"\"\"\n        source, = np_coerce(source)\n        if self.size is not None:\n            assert source.shape[-len(self.size):] == self.size, (source.shape, self.size)\n        return source\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Identity.__call__","title":"<code>__call__(source)</code>","text":"<p>embed the input.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>an input sequence</p> required <p>Returns:</p> Name Type Description <code>feature</code> <code>ArrayLike</code> <p>the input sequence as a numpy array.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __call__(self, source) -&gt; ArrayLike:\n    \"\"\"\n    embed the input.\n\n    Args:\n        source: an input sequence\n\n    Returns:\n        feature: the input sequence as a numpy array.\n    \"\"\"\n    source, = np_coerce(source)\n    if self.size is not None:\n        assert source.shape[-len(self.size):] == self.size, (source.shape, self.size)\n    return source\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Identity.__init__","title":"<code>__init__(size=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>both the Input and the Feature size. if supplied, inputs will be validated to be that size. otherwise, they will just be converted to ndarrays.</p> <code>None</code> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __init__(self, size:Optional[int]=None):\n    \"\"\"\n    Args:\n        size: both the Input and the Feature size.\n            if supplied, inputs will be validated to be that size.\n            otherwise, they will just be converted to ndarrays.\n    \"\"\"\n    super().__init__(size=size)\n    self.size = self.input_size = size\n    self.is_batched = True\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.ProjectAndSort","title":"<code>ProjectAndSort</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>Embedding for point cloud-like data. use with an L2 distance <code>Metric</code> to compute sliced optimal transport.</p> <p>if an Input is a 2D array [B x C], B being the point dimension (order not meaningful) and C being the coordinate dimension (order meaningful)</p> <p>e.g. [ [x0,y0,z0], [x1,y1,z1], [x2,y2,z2], [x3,y3,z3], ] would be a cloud of B=4 points in C=3 dimensional space</p> <p>This computes <code>n</code> pseudo-random projections down to 1-dimensional spaces, sorts along those lines, and then concatenates to make one feature vector. the L2 distance between feature vectors is the sliced OT distance between point clouds.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class ProjectAndSort(Embedding):\n    \"\"\"\n    Embedding for point cloud-like data.\n    use with an L2 distance `Metric` to compute sliced optimal transport.\n\n    if an Input is a 2D array [B x C],\n    B being the point dimension (order not meaningful)\n    and C being the coordinate dimension (order meaningful)\n\n    e.g.\n    [\n    [x0,y0,z0],\n    [x1,y1,z1],\n    [x2,y2,z2],\n    [x3,y3,z3],\n    ]\n    would be a cloud of B=4 points in C=3 dimensional space\n\n    This computes `n` pseudo-random projections down to 1-dimensional spaces,\n    sorts along those lines,\n    and then concatenates to make one feature vector.\n    the L2 distance between feature vectors is the sliced OT distance between point clouds.\n    \"\"\"\n    def __init__(self, input_size:Tuple[int,int]=None, n:int=16, seed:int=0):\n        \"\"\"\n        Args:\n            input_size: input shape [B,C]; if None, lazy init on first __call__\n            n: number of random projections.\n            seed: random seed.\n        \"\"\"\n        super().__init__(input_size=input_size, n=n)\n        self.n = n\n        self.seed = seed\n        self.is_batched = True\n\n        if input_size is not None:\n            self.init(input_size)\n        else:\n            self.input_size = None\n            self.size = None\n\n    def init(self, input_size):\n        assert len(input_size)&gt;=2, \"ProjectAndSort expects at least 2D array data\"\n\n        self.rng = np.random.default_rng(self.seed)\n\n        self.input_size = tuple(input_size)\n\n        self.size = input_size[0] * self.n\n\n        proj = self.rng.normal(size=(input_size[1], self.n))\n        proj = proj / np.linalg.norm(proj, axis=0, keepdims=True)\n        self.proj = proj\n\n    def __call__(self, source) -&gt; ArrayLike:\n        \"\"\"\n        embed the input.\n\n        Args:\n            source: an 2d input sequence of shape [batch x coordinates]     \n                representing a set of points.\n\n        Returns:\n            feature: 1d array of concatenated projections of the input points.\n        \"\"\"\n        source, = np_coerce(source)\n        if self.input_size is None:\n            # lazy init\n            self.init(source.shape[-2:])\n        else:\n            assert source.shape[-2:] == self.input_size, (source.shape, self.input_size)\n\n        # project coordinate dimension to n lines\n        feat = source @ self.proj\n        # sort along the lines\n        feat = np.sort(feat, axis=-2)\n        # flatten\n        # feat = feat.T\n        feat = feat.reshape((*feat.shape[:-2], -1))\n\n        return feat / np.sqrt(self.size)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.ProjectAndSort.__call__","title":"<code>__call__(source)</code>","text":"<p>embed the input.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>an 2d input sequence of shape [batch x coordinates]    representing a set of points.</p> required <p>Returns:</p> Name Type Description <code>feature</code> <code>ArrayLike</code> <p>1d array of concatenated projections of the input points.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __call__(self, source) -&gt; ArrayLike:\n    \"\"\"\n    embed the input.\n\n    Args:\n        source: an 2d input sequence of shape [batch x coordinates]     \n            representing a set of points.\n\n    Returns:\n        feature: 1d array of concatenated projections of the input points.\n    \"\"\"\n    source, = np_coerce(source)\n    if self.input_size is None:\n        # lazy init\n        self.init(source.shape[-2:])\n    else:\n        assert source.shape[-2:] == self.input_size, (source.shape, self.input_size)\n\n    # project coordinate dimension to n lines\n    feat = source @ self.proj\n    # sort along the lines\n    feat = np.sort(feat, axis=-2)\n    # flatten\n    # feat = feat.T\n    feat = feat.reshape((*feat.shape[:-2], -1))\n\n    return feat / np.sqrt(self.size)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.ProjectAndSort.__init__","title":"<code>__init__(input_size=None, n=16, seed=0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>input_size</code> <code>Tuple[int, int]</code> <p>input shape [B,C]; if None, lazy init on first call</p> <code>None</code> <code>n</code> <code>int</code> <p>number of random projections.</p> <code>16</code> <code>seed</code> <code>int</code> <p>random seed.</p> <code>0</code> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __init__(self, input_size:Tuple[int,int]=None, n:int=16, seed:int=0):\n    \"\"\"\n    Args:\n        input_size: input shape [B,C]; if None, lazy init on first __call__\n        n: number of random projections.\n        seed: random seed.\n    \"\"\"\n    super().__init__(input_size=input_size, n=n)\n    self.n = n\n    self.seed = seed\n    self.is_batched = True\n\n    if input_size is not None:\n        self.init(input_size)\n    else:\n        self.input_size = None\n        self.size = None\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Random","title":"<code>Random</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>Pseudo-random uniform embedding in [-1, 1] for any hashable inputs.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class Random(Embedding):\n    \"\"\"\n    Pseudo-random uniform embedding in [-1, 1] for any hashable inputs.\n    \"\"\"\n    def __init__(self, size:int=1):\n        \"\"\"\n        Args:\n            size: the Feature size.\n        \"\"\"\n        super().__init__(size=size)\n        self.input_size = None\n        self.size = size\n\n    def __call__(self, source) -&gt; ArrayLike:\n        \"\"\"\n        embed the input.\n\n        Args:\n            source: a hashable input. cannot be batched.\n\n        Returns:\n            feature: uniformly distributed pseudo-random vector\n        \"\"\"\n        # TODO: treat lists as batches?\n\n        # get 32 bits from the input\n        h = hash(source) &amp; 8589934591\n        rng = np.random.default_rng(h)\n        return rng.random(size=self.size)*2 - 1\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Random.__call__","title":"<code>__call__(source)</code>","text":"<p>embed the input.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>a hashable input. cannot be batched.</p> required <p>Returns:</p> Name Type Description <code>feature</code> <code>ArrayLike</code> <p>uniformly distributed pseudo-random vector</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __call__(self, source) -&gt; ArrayLike:\n    \"\"\"\n    embed the input.\n\n    Args:\n        source: a hashable input. cannot be batched.\n\n    Returns:\n        feature: uniformly distributed pseudo-random vector\n    \"\"\"\n    # TODO: treat lists as batches?\n\n    # get 32 bits from the input\n    h = hash(source) &amp; 8589934591\n    rng = np.random.default_rng(h)\n    return rng.random(size=self.size)*2 - 1\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Random.__init__","title":"<code>__init__(size=1)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>the Feature size.</p> <code>1</code> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __init__(self, size:int=1):\n    \"\"\"\n    Args:\n        size: the Feature size.\n    \"\"\"\n    super().__init__(size=size)\n    self.input_size = None\n    self.size = size\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.RandomNormal","title":"<code>RandomNormal</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>Pseudo-random Gaussian embedding for any hashable inputs.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class RandomNormal(Embedding):\n    \"\"\"\n    Pseudo-random Gaussian embedding for any hashable inputs.\n    \"\"\"\n    def __init__(self, size:int=1):\n        \"\"\"\n        Args:\n            size: the Feature size.\n        \"\"\"\n        super().__init__(size=size)\n        self.input_size = None\n        self.size = size\n\n    def __call__(self, source) -&gt; ArrayLike:\n        \"\"\"\n        embed the input.\n\n        Args:\n            source: an input sequence\n\n        Returns:\n            feature: normally distributed pseudo-random vector\n        \"\"\"\n        # get 32 bits from the input\n        h = hash(source) &amp; 8589934591\n        rng = np.random.default_rng(h)\n        return rng.normal(size=self.size)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.RandomNormal.__call__","title":"<code>__call__(source)</code>","text":"<p>embed the input.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>an input sequence</p> required <p>Returns:</p> Name Type Description <code>feature</code> <code>ArrayLike</code> <p>normally distributed pseudo-random vector</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __call__(self, source) -&gt; ArrayLike:\n    \"\"\"\n    embed the input.\n\n    Args:\n        source: an input sequence\n\n    Returns:\n        feature: normally distributed pseudo-random vector\n    \"\"\"\n    # get 32 bits from the input\n    h = hash(source) &amp; 8589934591\n    rng = np.random.default_rng(h)\n    return rng.normal(size=self.size)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.RandomNormal.__init__","title":"<code>__init__(size=1)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>the Feature size.</p> <code>1</code> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __init__(self, size:int=1):\n    \"\"\"\n    Args:\n        size: the Feature size.\n    \"\"\"\n    super().__init__(size=size)\n    self.input_size = None\n    self.size = size\n</code></pre>"},{"location":"reference/anguilla/interpolate/","title":"Interpolate","text":""},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Interpolate","title":"<code>Interpolate</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> <p><code>Interpolate</code> combines a set of <code>Outputs</code> weighted by dissimilarity scores.</p> <p>The scores depend on the <code>Metric</code> used by the <code>NNSearch</code>.  They may be, for example, distances or negative cosine similarities.</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Interpolate(JSONSerializable):\n    \"\"\"\n    `Interpolate` combines a set of `Outputs` weighted by dissimilarity scores.\n\n    The scores depend on the `Metric` used by the `NNSearch`. \n    They may be, for example, distances or negative cosine similarities.\n    \"\"\"\n    def __init__(self, **kw):\n        super().__init__(**kw)\n\n    def __call__(self, targets: List[Output], scores: Scores) -&gt; Output:\n        \"\"\"\n        Args:\n            targets: [k x &lt;batch dims&gt; x &lt;output dims&gt;]\n                first dimension is neighbor dimension\n                trailing dimensions are feature dimensions\n                remaining dimensions are batch dimensions\n            scores: [k]\n\n        Returns:\n            output: [&lt;batch dims&gt; x &lt;output dims&gt;]\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Interpolate.__call__","title":"<code>__call__(targets, scores)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>targets</code> <code>List[Output]</code> <p>[k x  x ] first dimension is neighbor dimension trailing dimensions are feature dimensions remaining dimensions are batch dimensions required <code>scores</code> <code>Scores</code> <p>[k]</p> required <p>Returns:</p> Name Type Description <code>output</code> <code>Output</code> <p>[ x ] Source code in <code>src/anguilla/interpolate.py</code> <pre><code>def __call__(self, targets: List[Output], scores: Scores) -&gt; Output:\n    \"\"\"\n    Args:\n        targets: [k x &lt;batch dims&gt; x &lt;output dims&gt;]\n            first dimension is neighbor dimension\n            trailing dimensions are feature dimensions\n            remaining dimensions are batch dimensions\n        scores: [k]\n\n    Returns:\n        output: [&lt;batch dims&gt; x &lt;output dims&gt;]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Mean","title":"<code>Mean</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>mean of neighbors (piecewise constant mapping)</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Mean(Interpolate):\n    \"\"\"mean of neighbors (piecewise constant mapping)\"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets, scores):\n        return sum(targets) / len(targets)\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Nearest","title":"<code>Nearest</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>return nearest neighbor (voronoi cell mapping)</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Nearest(Interpolate):\n    \"\"\"return nearest neighbor (voronoi cell mapping)\"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets, scores):\n        idx = np.argmin(scores, 0)\n        if idx.ndim &gt; 1:\n            return [targets[i,j] for j,i in enumerate(idx)]\n        else:\n            return targets[idx]\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Ripple","title":"<code>Ripple</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>like <code>Smooth</code> but with high-frequency ripples outside the input domain.</p> <p>useful for making random mappings in high dimensional spaces / bootstrapping expressive mappings from a few points.</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Ripple(Interpolate):\n    \"\"\"\n    like `Smooth` but with high-frequency ripples outside the input domain.\n\n    useful for making random mappings in high dimensional spaces / bootstrapping expressive mappings from a few points.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, \n            targets:List[Output], scores:List[float], \n            ripple:float=1, ripple_depth:float=1, eps:float=1e-9):\n        \"\"\"\n        Args:\n            targets: size [K x ...output_dims...] list or ndarray\n            scores: size [K] list or ndarray\n            ripple: frequency of ripples\n            ripple_depth: amplitude of ripples\n            eps: small value preventing division by zero\n        \"\"\"\n        targets, scores = np_coerce(targets, scores)\n\n        scores = scores + eps\n        assert np.min(scores) &gt; 0\n\n        # largest scores -&gt; 0 weight\n        # zero score -&gt; inf weight\n        mx = np.max(scores, 0)\n        weights = 1/scores + (-3*mx*mx + 3*mx*scores - scores*scores)/(mx**3)\n        weights = weights * 2**(\n            ripple_depth * \n            (1+np.cos(np.pi*scores/mx)*np.sin(scores*np.pi*ripple))\n            )\n\n        weights = weights + eps\n        weights = weights / weights.sum(0)\n\n        # result = (np.moveaxis(targets,0,-1)*weights).sum(-1)\n        result = np.transpose((\n            np.transpose(targets)*np.transpose(weights)).sum(-1))\n\n        return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Ripple.__call__","title":"<code>__call__(targets, scores, ripple=1, ripple_depth=1, eps=1e-09)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>targets</code> <code>List[Output]</code> <p>size [K x ...output_dims...] list or ndarray</p> required <code>scores</code> <code>List[float]</code> <p>size [K] list or ndarray</p> required <code>ripple</code> <code>float</code> <p>frequency of ripples</p> <code>1</code> <code>ripple_depth</code> <code>float</code> <p>amplitude of ripples</p> <code>1</code> <code>eps</code> <code>float</code> <p>small value preventing division by zero</p> <code>1e-09</code> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>def __call__(self, \n        targets:List[Output], scores:List[float], \n        ripple:float=1, ripple_depth:float=1, eps:float=1e-9):\n    \"\"\"\n    Args:\n        targets: size [K x ...output_dims...] list or ndarray\n        scores: size [K] list or ndarray\n        ripple: frequency of ripples\n        ripple_depth: amplitude of ripples\n        eps: small value preventing division by zero\n    \"\"\"\n    targets, scores = np_coerce(targets, scores)\n\n    scores = scores + eps\n    assert np.min(scores) &gt; 0\n\n    # largest scores -&gt; 0 weight\n    # zero score -&gt; inf weight\n    mx = np.max(scores, 0)\n    weights = 1/scores + (-3*mx*mx + 3*mx*scores - scores*scores)/(mx**3)\n    weights = weights * 2**(\n        ripple_depth * \n        (1+np.cos(np.pi*scores/mx)*np.sin(scores*np.pi*ripple))\n        )\n\n    weights = weights + eps\n    weights = weights / weights.sum(0)\n\n    # result = (np.moveaxis(targets,0,-1)*weights).sum(-1)\n    result = np.transpose((\n        np.transpose(targets)*np.transpose(weights)).sum(-1))\n\n    return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Smooth","title":"<code>Smooth</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>Interpolate which is non-discontinuous (for <code>k</code> &gt; 2)</p> <p>tries to prevent discontinuities while preserving the input-output mapping exactly where close to data points.</p> <p>works well with larger <code>k</code>. out-of-domain input areas tend to be averages of many outputs.</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Smooth(Interpolate):\n    \"\"\"\n    Interpolate which is non-discontinuous (for `k` &gt; 2)\n\n    tries to prevent discontinuities while preserving the input-output mapping\n    exactly where close to data points.\n\n    works well with larger `k`.\n    out-of-domain input areas tend to be averages of many outputs.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets:List[Output], scores:List[float], eps:float=1e-9):\n        \"\"\"\n        Args:\n            targets: size [K x ...batch dims... x ...output_dims...] \n            scores: size [K x ...batch dims...] \n            eps: small value preventing division by zero\n        \"\"\"\n        targets, scores = np_coerce(targets, scores)\n\n        scores = scores + eps\n        assert np.min(scores) &gt; 0\n\n        # largest scores -&gt; 0 weight\n        # zero score -&gt; inf weight\n        # zero first/second derivative at largest score\n        mx = np.max(scores, 0)\n        weights = 1/scores + (-3*mx*mx + 3*mx*scores - scores*scores)/(mx**3)\n\n        weights = weights + eps\n        weights = weights / weights.sum(0)\n\n        # result = (np.moveaxis(targets,0,-1)*weights).sum(-1)\n        result = np.transpose((\n            np.transpose(targets)*np.transpose(weights)).sum(-1))\n\n        return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Smooth.__call__","title":"<code>__call__(targets, scores, eps=1e-09)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>targets</code> <code>List[Output]</code> <p>size [K x ...batch dims... x ...output_dims...] </p> required <code>scores</code> <code>List[float]</code> <p>size [K x ...batch dims...] </p> required <code>eps</code> <code>float</code> <p>small value preventing division by zero</p> <code>1e-09</code> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>def __call__(self, targets:List[Output], scores:List[float], eps:float=1e-9):\n    \"\"\"\n    Args:\n        targets: size [K x ...batch dims... x ...output_dims...] \n        scores: size [K x ...batch dims...] \n        eps: small value preventing division by zero\n    \"\"\"\n    targets, scores = np_coerce(targets, scores)\n\n    scores = scores + eps\n    assert np.min(scores) &gt; 0\n\n    # largest scores -&gt; 0 weight\n    # zero score -&gt; inf weight\n    # zero first/second derivative at largest score\n    mx = np.max(scores, 0)\n    weights = 1/scores + (-3*mx*mx + 3*mx*scores - scores*scores)/(mx**3)\n\n    weights = weights + eps\n    weights = weights / weights.sum(0)\n\n    # result = (np.moveaxis(targets,0,-1)*weights).sum(-1)\n    result = np.transpose((\n        np.transpose(targets)*np.transpose(weights)).sum(-1))\n\n    return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Softmax","title":"<code>Softmax</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>Like <code>Mean</code>, but weighted toward the nearer neighbors.</p> <p>when <code>k</code> is small, has discontinuities when temp is large, acts more like <code>Mean</code>. -&gt; tends to get 'washed out' for larger <code>k</code> / larger temp</p> <p>when temp is small, acts more like <code>Nearest</code> (voronoi cells).</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Softmax(Interpolate):\n    \"\"\"\n    Like `Mean`, but weighted toward the nearer neighbors.\n\n    when `k` is small, has discontinuities\n    when temp is large, acts more like `Mean`.\n    -&gt; tends to get 'washed out' for larger `k` / larger temp\n\n    when temp is small, acts more like `Nearest` (voronoi cells).\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets:List[Output], scores:List[float], temp:float=0.5):\n        \"\"\"\n        Args:\n            targets: size [K x ...batch dims... x ...output_dims...] \n            scores: size [K x ...batch dims...] \n            temp: temperature of softmax\n        \"\"\"\n        targets, scores = np_coerce(targets, scores)\n        # print(targets.shape, scores.shape)\n\n        if temp==0:\n            result = Nearest()(targets, scores)\n        else:\n            centered = scores - np.mean(scores, 0) # for numerical precision\n            logits = np.maximum(-centered/temp, -20)\n            # print(f'{logits=}')\n            if np.max(np.abs(logits)) &gt; 80:\n                # NOTE: not batched properly\n                result = Nearest()(targets, scores)\n            else:\n                weights = np.exp(logits)\n                # print(f'{weights=}')\n                weights /= weights.sum(0)\n                # print(f'{weights=}')\n                # result = (np.moveaxis(targets,0,-1)*weights).sum(-1)\n                result = np.transpose((\n                    np.transpose(targets)*np.transpose(weights)).sum(-1))\n        # print(f'{result=}')\n        return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Softmax.__call__","title":"<code>__call__(targets, scores, temp=0.5)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>targets</code> <code>List[Output]</code> <p>size [K x ...batch dims... x ...output_dims...] </p> required <code>scores</code> <code>List[float]</code> <p>size [K x ...batch dims...] </p> required <code>temp</code> <code>float</code> <p>temperature of softmax</p> <code>0.5</code> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>def __call__(self, targets:List[Output], scores:List[float], temp:float=0.5):\n    \"\"\"\n    Args:\n        targets: size [K x ...batch dims... x ...output_dims...] \n        scores: size [K x ...batch dims...] \n        temp: temperature of softmax\n    \"\"\"\n    targets, scores = np_coerce(targets, scores)\n    # print(targets.shape, scores.shape)\n\n    if temp==0:\n        result = Nearest()(targets, scores)\n    else:\n        centered = scores - np.mean(scores, 0) # for numerical precision\n        logits = np.maximum(-centered/temp, -20)\n        # print(f'{logits=}')\n        if np.max(np.abs(logits)) &gt; 80:\n            # NOTE: not batched properly\n            result = Nearest()(targets, scores)\n        else:\n            weights = np.exp(logits)\n            # print(f'{weights=}')\n            weights /= weights.sum(0)\n            # print(f'{weights=}')\n            # result = (np.moveaxis(targets,0,-1)*weights).sum(-1)\n            result = np.transpose((\n                np.transpose(targets)*np.transpose(weights)).sum(-1))\n    # print(f'{result=}')\n    return result\n</code></pre>"},{"location":"reference/anguilla/nnsearch/","title":"Nnsearch","text":""},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.Index","title":"<code>Index</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> <p>base Index class. currently no function besides typing, warning of unimplemented features.</p> <p>Subclasses of Index implement nearest neighbor search with different cababilities and performance tradeoffs.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class Index(JSONSerializable):\n    \"\"\"\n    base Index class.\n    currently no function besides typing, warning of unimplemented features.\n\n    Subclasses of Index implement nearest neighbor search with different\n    cababilities and performance tradeoffs.\n    \"\"\"\n    def __init__(self, **kw):\n        super().__init__(**kw)\n        self.is_batched = False\n\n    def add(self, feature:Feature, id:Optional[PairID]=None):\n        raise NotImplementedError\n    def remove(self, id:PairID):\n        raise NotImplementedError\n    def get(self, id:PairID):\n        raise NotImplementedError\n    def search(self, feature:Feature, k:int) -&gt; Tuple[Scores, PairIDs]:\n        raise NotImplementedError\n    def reset(self):\n        raise NotImplementedError\n    @property\n    def ids(self):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute","title":"<code>IndexBrute</code>","text":"<p>             Bases: <code>Index</code></p> <p>Optimized for simplicity and flexibility, may not scale to large datasets.</p> <p>NOTE: currently no batching support.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class IndexBrute(Index):\n    \"\"\"\n    Optimized for simplicity and flexibility,\n    may not scale to large datasets.\n\n    NOTE: currently no batching support.\n    \"\"\"\n    def __init__(self, d:int=None, metric:Callable=None):\n        \"\"\"\n        Args:\n            d: optional, dimension of feature\n            metric: distance metric, default to squared euclidean\n        \"\"\"\n        if metric is None:\n            metric = sqL2()\n\n        super().__init__(d=d, metric=metric)\n        self.d = d\n        self.metric = metric\n\n        self.reset()\n\n    def add(self, feature:Feature, id:Optional[PairID]=None) -&gt; PairID:\n        \"\"\"add a new feature, return its ID.\n        Args:\n            feature: the feature to add\n            id: if not supplied, generate a new ID;\n                otherwise, use the supplied id.\n                supply an existing id to replace.\n        \"\"\"\n        if id is None:\n            id = max(self.data, default=-1) + 1\n        self.data[id] = feature\n        return id\n\n    def remove(self, id:PairID):\n        \"\"\"remove a feature by ID\"\"\"\n        del self.data[id]\n\n    def get(self, id:PairID) -&gt; Feature:\n        \"\"\"get a feature by ID\"\"\"\n        return self.data[id]\n\n    def search(self, feature:Feature, k:int=3) -&gt; Tuple[PairIDs, Scores]:\n        \"\"\"get feature(s) and IDs by proximity\"\"\"\n        if not len(self.data):\n            return [], []\n        dist_id = sorted((self.metric(feature, v),k) for k,v in self.data.items())\n        scores, ids = zip(*dist_id[:k])\n        return ids, scores\n\n    def reset(self):\n        self.data:Dict[PairID, Feature] = {}\n\n    @property\n    def ids(self):\n        return self.data.keys()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.__init__","title":"<code>__init__(d=None, metric=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>d</code> <code>int</code> <p>optional, dimension of feature</p> <code>None</code> <code>metric</code> <code>Callable</code> <p>distance metric, default to squared euclidean</p> <code>None</code> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __init__(self, d:int=None, metric:Callable=None):\n    \"\"\"\n    Args:\n        d: optional, dimension of feature\n        metric: distance metric, default to squared euclidean\n    \"\"\"\n    if metric is None:\n        metric = sqL2()\n\n    super().__init__(d=d, metric=metric)\n    self.d = d\n    self.metric = metric\n\n    self.reset()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.add","title":"<code>add(feature, id=None)</code>","text":"<p>add a new feature, return its ID. Args:     feature: the feature to add     id: if not supplied, generate a new ID;         otherwise, use the supplied id.         supply an existing id to replace.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def add(self, feature:Feature, id:Optional[PairID]=None) -&gt; PairID:\n    \"\"\"add a new feature, return its ID.\n    Args:\n        feature: the feature to add\n        id: if not supplied, generate a new ID;\n            otherwise, use the supplied id.\n            supply an existing id to replace.\n    \"\"\"\n    if id is None:\n        id = max(self.data, default=-1) + 1\n    self.data[id] = feature\n    return id\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.get","title":"<code>get(id)</code>","text":"<p>get a feature by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def get(self, id:PairID) -&gt; Feature:\n    \"\"\"get a feature by ID\"\"\"\n    return self.data[id]\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.remove","title":"<code>remove(id)</code>","text":"<p>remove a feature by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove(self, id:PairID):\n    \"\"\"remove a feature by ID\"\"\"\n    del self.data[id]\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.search","title":"<code>search(feature, k=3)</code>","text":"<p>get feature(s) and IDs by proximity</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def search(self, feature:Feature, k:int=3) -&gt; Tuple[PairIDs, Scores]:\n    \"\"\"get feature(s) and IDs by proximity\"\"\"\n    if not len(self.data):\n        return [], []\n    dist_id = sorted((self.metric(feature, v),k) for k,v in self.data.items())\n    scores, ids = zip(*dist_id[:k])\n    return ids, scores\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast","title":"<code>IndexFast</code>","text":"<p>             Bases: <code>Index</code></p> <p>Optimized for fast <code>search</code> on large vectors / datasets. Only L2 distance supported.  <code>remove</code> may be slow.</p> <p>This is currently a wrapper around <code>faiss.FlatIndexL2</code> which provides stable ids when using <code>remove</code>. In the future could support dot product and/or approximate search indices.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class IndexFast(Index):\n    \"\"\"\n    Optimized for fast `search` on large vectors / datasets.\n    Only L2 distance supported. \n    `remove` may be slow.\n\n    This is currently a wrapper around `faiss.FlatIndexL2` which provides stable ids when using `remove`.\n    In the future could support dot product and/or approximate search indices.\n    \"\"\"\n    def __init__(self, d:int, metric:Callable=sqL2):\n        \"\"\"\n        Args:\n            d: dimension of feature\n            metric: \n        \"\"\"\n        super().__init__(d=d, metric=metric)\n        self.is_batched = True # `search` supports batching\n\n        if isinstance(metric, type) and issubclass(metric, Metric):\n            self.metric = metric()\n        else:\n            self.metric = metric\n        self.index = None\n        if d is not None:\n            self.init(d)\n\n    def init(self, d):\n        if isinstance(self.metric, sqL2):\n            self.index = IndexFlatL2(d)\n        else:\n            raise ValueError(\"\"\"IndexFast supports only sqL2 metric\"\"\")\n        self.reset()\n\n    @property\n    def d(self):\n        return self.index.d\n\n    def add(self, feature:Feature, id:Optional[PairID]=None):\n        \"\"\"add a new feature, return its ID.\n        Args:\n            feature: the feature to add\n            id: if not supplied, generate a new ID;\n                otherwise, use the supplied id.\n                supply an existing id to replace.\n        \"\"\"\n        if self.index is None:\n            self.init(feature.shape[-1])\n\n        if id is None:\n            # no id supplied case\n            id = max(self.id_to_idx, default=-1) + 1\n        elif id in self.id_to_idx:\n            # existing id supplied case\n            self.remove(id)\n        feature = feature[None].astype(np.float32)\n        self.index.add(feature)\n        idx = self.index.ntotal - 1\n        # map ID to faiss index\n        self.id_to_idx[id] = idx\n        self.idx_to_id[idx] = id\n        return id\n\n    def remove(self, id:PairID):\n        \"\"\"remove a feature by ID\"\"\"\n        idx = self.id_to_idx[id]\n        self.index.remove_ids(np.array(idx)[None])\n        del self.id_to_idx[id]\n        del self.idx_to_id[idx]\n        # faiss shifts its internal index to stay dense\n        self.id_to_idx = {\n            k:(v-1 if v &gt; idx else v) for k,v in self.id_to_idx.items()}\n        self.idx_to_id = {\n            (k-1 if k &gt; idx else k):v for k,v in self.idx_to_id.items()}\n\n    def get(self, id:PairID):\n        \"\"\"get a feature by ID\"\"\"\n        idx = self.id_to_idx[id]\n        return self.index.reconstruct(idx)\n\n    def search(self, feature:Feature, k:int=3) -&gt; Tuple[PairIDs, Scores]:\n        \"\"\"get feature(s) and IDs by proximity\"\"\"\n        feature, = np_coerce(feature)\n        batch = feature.ndim&gt;1\n        # print(f'{batch=}', feature.ndim)\n        feature = feature.astype(np.float32) \n        if not batch:\n            feature = feature[None]\n\n        scores, idxs = self.index.search(feature, k)\n\n        # remove -1 ids\n        # assuming pattern of missing is same across batch\n        # should be, since only reason for missing is &lt;k data points\n        b = [i&gt;=0 for i in idxs[0]] \n        scores, idxs = scores[:,b], idxs[:,b]\n\n        # map back to ids\n        ids = [[self.idx_to_id[i] for i in idx] for idx in idxs]\n\n        if not batch:\n            # remove batch dim\n            scores, ids = scores[0], ids[0]\n\n        # # remove batch dim\n        # scores, idxs = scores[0], idxs[0]\n        # # remove -1 ids\n        # b = [i&gt;=0 for i in idxs] \n        # scores, idxs = scores[b], idxs[b]\n        # # map back to ids\n        # ids = [self.idx_to_id[i] for i in idxs]\n        return ids, scores  \n\n    def reset(self):\n        if self.index is not None:\n            self.index.reset()\n        self.idx_to_id:Dict[int, PairID] = {}\n        self.id_to_idx:Dict[PairID, int] = {}\n\n    @property\n    def ids(self):\n        return self.id_to_idx.keys()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.__init__","title":"<code>__init__(d, metric=sqL2)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>d</code> <code>int</code> <p>dimension of feature</p> required <code>metric</code> <code>Callable</code> <code>sqL2</code> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __init__(self, d:int, metric:Callable=sqL2):\n    \"\"\"\n    Args:\n        d: dimension of feature\n        metric: \n    \"\"\"\n    super().__init__(d=d, metric=metric)\n    self.is_batched = True # `search` supports batching\n\n    if isinstance(metric, type) and issubclass(metric, Metric):\n        self.metric = metric()\n    else:\n        self.metric = metric\n    self.index = None\n    if d is not None:\n        self.init(d)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.add","title":"<code>add(feature, id=None)</code>","text":"<p>add a new feature, return its ID. Args:     feature: the feature to add     id: if not supplied, generate a new ID;         otherwise, use the supplied id.         supply an existing id to replace.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def add(self, feature:Feature, id:Optional[PairID]=None):\n    \"\"\"add a new feature, return its ID.\n    Args:\n        feature: the feature to add\n        id: if not supplied, generate a new ID;\n            otherwise, use the supplied id.\n            supply an existing id to replace.\n    \"\"\"\n    if self.index is None:\n        self.init(feature.shape[-1])\n\n    if id is None:\n        # no id supplied case\n        id = max(self.id_to_idx, default=-1) + 1\n    elif id in self.id_to_idx:\n        # existing id supplied case\n        self.remove(id)\n    feature = feature[None].astype(np.float32)\n    self.index.add(feature)\n    idx = self.index.ntotal - 1\n    # map ID to faiss index\n    self.id_to_idx[id] = idx\n    self.idx_to_id[idx] = id\n    return id\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.get","title":"<code>get(id)</code>","text":"<p>get a feature by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def get(self, id:PairID):\n    \"\"\"get a feature by ID\"\"\"\n    idx = self.id_to_idx[id]\n    return self.index.reconstruct(idx)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.remove","title":"<code>remove(id)</code>","text":"<p>remove a feature by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove(self, id:PairID):\n    \"\"\"remove a feature by ID\"\"\"\n    idx = self.id_to_idx[id]\n    self.index.remove_ids(np.array(idx)[None])\n    del self.id_to_idx[id]\n    del self.idx_to_id[idx]\n    # faiss shifts its internal index to stay dense\n    self.id_to_idx = {\n        k:(v-1 if v &gt; idx else v) for k,v in self.id_to_idx.items()}\n    self.idx_to_id = {\n        (k-1 if k &gt; idx else k):v for k,v in self.idx_to_id.items()}\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.search","title":"<code>search(feature, k=3)</code>","text":"<p>get feature(s) and IDs by proximity</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def search(self, feature:Feature, k:int=3) -&gt; Tuple[PairIDs, Scores]:\n    \"\"\"get feature(s) and IDs by proximity\"\"\"\n    feature, = np_coerce(feature)\n    batch = feature.ndim&gt;1\n    # print(f'{batch=}', feature.ndim)\n    feature = feature.astype(np.float32) \n    if not batch:\n        feature = feature[None]\n\n    scores, idxs = self.index.search(feature, k)\n\n    # remove -1 ids\n    # assuming pattern of missing is same across batch\n    # should be, since only reason for missing is &lt;k data points\n    b = [i&gt;=0 for i in idxs[0]] \n    scores, idxs = scores[:,b], idxs[:,b]\n\n    # map back to ids\n    ids = [[self.idx_to_id[i] for i in idx] for idx in idxs]\n\n    if not batch:\n        # remove batch dim\n        scores, ids = scores[0], ids[0]\n\n    # # remove batch dim\n    # scores, idxs = scores[0], idxs[0]\n    # # remove -1 ids\n    # b = [i&gt;=0 for i in idxs] \n    # scores, idxs = scores[b], idxs[b]\n    # # map back to ids\n    # ids = [self.idx_to_id[i] for i in idxs]\n    return ids, scores  \n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.Metric","title":"<code>Metric</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> <p>define a distance between two points.  Relative distances will be used to find nearest neighbors, and the distances to neighbors will be passed to <code>Interpolate</code>.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class Metric(JSONSerializable):\n    \"\"\"\n    define a distance between two points. \n    Relative distances will be used to find nearest neighbors,\n    and the distances to neighbors will be passed to `Interpolate`.\n    \"\"\"\n    def __call__(self, a, b):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch","title":"<code>NNSearch</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> <p>This class is the mid-level interface for neighbor search, providing some common utilities over the Index subclasses. Users will generally use <code>IML.search</code> instead of calling <code>NNSearch</code> directly.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class NNSearch(JSONSerializable):\n    \"\"\"\n    This class is the mid-level interface for neighbor search,\n    providing some common utilities over the Index subclasses.\n    Users will generally use `IML.search` instead of calling `NNSearch` directly.\n    \"\"\"\n    # TODO: possibly get rid of this class and fold it into IML?\n    #     * currently adds only complexity to the IML implementation\n    #     * but could be useful if needing NNSearch without Embed/Interpolate?\n    def __init__(self, index:Index, k=10):\n        \"\"\"\n        Args:\n            index: instance of `Index`\n            k: default k-nearest neighbors (but can be overridden later)\n        \"\"\"\n        super().__init__(index=index, k=k)\n        self.index = index\n        self.default_k = k\n\n    def __call__(self, feature:Feature, k:int=None) -&gt; Tuple[PairIDs, Scores]:\n        \"\"\"\n        find the k-nearest neighbors of `feature`\n        Args:\n            feature: query feature vector\n            k: maximum number of neighbors to return\n        Returns:\n            ids: ids of neighbors\n            scores: similarity scores of neighbors (higher is more similar)\n        \"\"\"\n        k = k or self.default_k\n        return self.index.search(feature, k)\n\n    def distance(self, a:Feature, b:Feature) -&gt; float:\n        \"\"\"compute distance between two features\"\"\"\n        return self.index.metric(a, b)\n\n    def add(self, feature: Feature, id:Optional[PairID]=None) -&gt; PairID:\n        \"\"\"add a feature vector to the index and return its ID\"\"\"\n        return self.index.add(feature, id)\n\n    def get(self, id:PairID) -&gt; Feature:\n        \"\"\"look up a feature by ID\"\"\"\n        try:\n            return self.index.get(id)\n        except Exception:\n            print(f\"NNSearch: WARNING: can't `get` ID {id} which doesn't exist or has been removed\")\n\n\n    def remove(self, id: Union[PairID, PairIDs], batch:bool=False):\n        \"\"\"\n        Remove point(s) from the index by ID\n\n        Args:\n            id: id or sequence of ids\n            batch: True if removing a batch of ids, False if a single id.\n        \"\"\"        \n        if batch:\n            return [self.remove(i) for i in id]\n        else:\n            try:\n                return self.index.remove(id)\n            except Exception:\n                print(f\"NNSearch: WARNING: can't `remove` ID {id} which doesn't exist or has already been removed\")\n\n    def remove_near(self, feature:Feature, k:int=None) -&gt; PairIDs:\n        \"\"\"\n        Remove point(s) from the index by proximity.\n        Use k=1 to remove a single point.\n        \"\"\"\n        # TODO: batching support?\n        k = k or self.default_k\n        ids, _ = self(feature, k=k)\n        self.remove(ids, batch=True)\n        return ids\n\n    def reset(self):\n        \"\"\"clear all data from the index\"\"\"\n        self.index.reset()\n\n    def __iter__(self):\n        \"\"\"iterate over IDs in the index\"\"\"\n        return iter(self.index.ids)\n\n    def items(self) -&gt; Generator[IDFeaturePair, None, None]:\n        \"\"\"iterate over ID, Feature pairs\"\"\"\n        def iterator():\n            for id in self.index.ids:\n                yield IDFeaturePair(id, self.index.get(id))\n        return iterator()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.__call__","title":"<code>__call__(feature, k=None)</code>","text":"<p>find the k-nearest neighbors of <code>feature</code> Args:     feature: query feature vector     k: maximum number of neighbors to return Returns:     ids: ids of neighbors     scores: similarity scores of neighbors (higher is more similar)</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __call__(self, feature:Feature, k:int=None) -&gt; Tuple[PairIDs, Scores]:\n    \"\"\"\n    find the k-nearest neighbors of `feature`\n    Args:\n        feature: query feature vector\n        k: maximum number of neighbors to return\n    Returns:\n        ids: ids of neighbors\n        scores: similarity scores of neighbors (higher is more similar)\n    \"\"\"\n    k = k or self.default_k\n    return self.index.search(feature, k)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.__init__","title":"<code>__init__(index, k=10)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>index</code> <code>Index</code> <p>instance of <code>Index</code></p> required <code>k</code> <p>default k-nearest neighbors (but can be overridden later)</p> <code>10</code> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __init__(self, index:Index, k=10):\n    \"\"\"\n    Args:\n        index: instance of `Index`\n        k: default k-nearest neighbors (but can be overridden later)\n    \"\"\"\n    super().__init__(index=index, k=k)\n    self.index = index\n    self.default_k = k\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.__iter__","title":"<code>__iter__()</code>","text":"<p>iterate over IDs in the index</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __iter__(self):\n    \"\"\"iterate over IDs in the index\"\"\"\n    return iter(self.index.ids)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.add","title":"<code>add(feature, id=None)</code>","text":"<p>add a feature vector to the index and return its ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def add(self, feature: Feature, id:Optional[PairID]=None) -&gt; PairID:\n    \"\"\"add a feature vector to the index and return its ID\"\"\"\n    return self.index.add(feature, id)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.distance","title":"<code>distance(a, b)</code>","text":"<p>compute distance between two features</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def distance(self, a:Feature, b:Feature) -&gt; float:\n    \"\"\"compute distance between two features\"\"\"\n    return self.index.metric(a, b)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.get","title":"<code>get(id)</code>","text":"<p>look up a feature by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def get(self, id:PairID) -&gt; Feature:\n    \"\"\"look up a feature by ID\"\"\"\n    try:\n        return self.index.get(id)\n    except Exception:\n        print(f\"NNSearch: WARNING: can't `get` ID {id} which doesn't exist or has been removed\")\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.items","title":"<code>items()</code>","text":"<p>iterate over ID, Feature pairs</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def items(self) -&gt; Generator[IDFeaturePair, None, None]:\n    \"\"\"iterate over ID, Feature pairs\"\"\"\n    def iterator():\n        for id in self.index.ids:\n            yield IDFeaturePair(id, self.index.get(id))\n    return iterator()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.remove","title":"<code>remove(id, batch=False)</code>","text":"<p>Remove point(s) from the index by ID</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>Union[PairID, PairIDs]</code> <p>id or sequence of ids</p> required <code>batch</code> <code>bool</code> <p>True if removing a batch of ids, False if a single id.</p> <code>False</code> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove(self, id: Union[PairID, PairIDs], batch:bool=False):\n    \"\"\"\n    Remove point(s) from the index by ID\n\n    Args:\n        id: id or sequence of ids\n        batch: True if removing a batch of ids, False if a single id.\n    \"\"\"        \n    if batch:\n        return [self.remove(i) for i in id]\n    else:\n        try:\n            return self.index.remove(id)\n        except Exception:\n            print(f\"NNSearch: WARNING: can't `remove` ID {id} which doesn't exist or has already been removed\")\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.remove_near","title":"<code>remove_near(feature, k=None)</code>","text":"<p>Remove point(s) from the index by proximity. Use k=1 to remove a single point.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove_near(self, feature:Feature, k:int=None) -&gt; PairIDs:\n    \"\"\"\n    Remove point(s) from the index by proximity.\n    Use k=1 to remove a single point.\n    \"\"\"\n    # TODO: batching support?\n    k = k or self.default_k\n    ids, _ = self(feature, k=k)\n    self.remove(ids, batch=True)\n    return ids\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.reset","title":"<code>reset()</code>","text":"<p>clear all data from the index</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def reset(self):\n    \"\"\"clear all data from the index\"\"\"\n    self.index.reset()\n</code></pre>"},{"location":"reference/anguilla/serialize/","title":"Serialize","text":""},{"location":"reference/anguilla/serialize/#anguilla.serialize.JSONSerializable","title":"<code>JSONSerializable</code>","text":"<p>JSON serialization for Python classes. Saves keyword arguments at construction, and also any state returned by the <code>save_state</code> method.</p> <p>to make class a serializable, subclass JSONSerializable,  and in the constructor use e.g. <code>super().__init__(a=0, b=1 ...)</code> with any keyword args which should be serialized.</p> <p>override <code>save_state</code> and <code>load_state</code> to handle any mutable state.</p> <p>Constructor args and return values of <code>save_state</code> can be other JSONSerializable objects.</p> Source code in <code>src/anguilla/serialize.py</code> <pre><code>class JSONSerializable:\n    \"\"\"JSON serialization for Python classes.\n    Saves keyword arguments at construction,\n    and also any state returned by the `save_state` method.\n\n    to make class a serializable, subclass JSONSerializable, \n    and in the constructor use e.g. `super().__init__(a=0, b=1 ...)`\n    with any keyword args which should be serialized.\n\n    override `save_state` and `load_state` to handle any mutable state.\n\n    Constructor args and return values of `save_state` can be other JSONSerializable objects.\n    \"\"\"\n    def __init__(self, **kw):\n        self._kw = deepcopy(kw)\n        self._kw['__inst__'] = '.'.join((\n            self.__class__.__module__,\n            self.__class__.__name__))\n\n    def _store(self):\n        return {'__state__': self.save_state(), **self._kw}\n\n    def save_state(self):\n        \"\"\"return object state in JSON serializable form\"\"\"\n        return None\n\n    def load_state(self, state):\n        \"\"\"restore from de-serialized state\"\"\"\n        pass\n</code></pre>"},{"location":"reference/anguilla/serialize/#anguilla.serialize.JSONSerializable.load_state","title":"<code>load_state(state)</code>","text":"<p>restore from de-serialized state</p> Source code in <code>src/anguilla/serialize.py</code> <pre><code>def load_state(self, state):\n    \"\"\"restore from de-serialized state\"\"\"\n    pass\n</code></pre>"},{"location":"reference/anguilla/serialize/#anguilla.serialize.JSONSerializable.save_state","title":"<code>save_state()</code>","text":"<p>return object state in JSON serializable form</p> Source code in <code>src/anguilla/serialize.py</code> <pre><code>def save_state(self):\n    \"\"\"return object state in JSON serializable form\"\"\"\n    return None\n</code></pre>"},{"location":"reference/anguilla/types/","title":"Types","text":""},{"location":"reference/anguilla/app/__init__/","title":"init","text":""},{"location":"reference/anguilla/app/server/","title":"Server","text":"Authors <p>Victor Shepardson Intelligent Instruments Lab 2023</p>"},{"location":"reference/anguilla/app/server/#anguilla.app.server.main","title":"<code>main(osc_port=8732, osc_return_port=None, osc_host='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>osc_port</code> <code>int</code> <p>listen for OSC controls on this port</p> <code>8732</code> <code>osc_return_port</code> <code>Optional[int]</code> <p>if supplied, reply on a different port than osc_port</p> <code>None</code> <code>osc_host</code> <code>str</code> <p>leave this as empty string to get all traffic on the port</p> <code>''</code> <p>OSC Routes:</p> <pre><code>/anguilla/config \"emb\" \"Identity\"\n    set embedding to Identity (the default)\n/anguilla/config \"emb\" \"ProjectAndSort\"\n    set embedding to ProjectAndSort\n\n/anguilla/config \"interp\" \"Smooth\"\n    set interpolator to Smooth (the default)\n/anguilla/config \"interp\" \"Softmax\"\n    set interpolator to Softmax\n/anguilla/config \"interp\" \"Ripple\"\n    set interpolator to Ripple\n\n/anguilla/add \"input\" ... \"output\"... \n    add a point to the mapping\n\n/anguilla/remove id \n    remove a point from the mapping by ID\n\n/anguilla/remove_near \"input\" ... [\"k\" k]\n    remove k points from the mapping by proximity\n\n/anguilla/map \"input\" ... [\"k\" k] [\"ripple\" r] [\"temp\" t]\n    map an input to an output using k neighbors\n    \"temp\" 1 &gt; t &gt; 0 when using Softmax interpolator\n    \"ripple\" r &gt; 0 when using Ripple interpolator\n\n/anguilla/reset\n    remove all points\n/anguilla/reset \"keep_near\" ... [\"k\" k]\n    remove all points except the k neighbors of \"keep_near\"\n\n/anguilla/load path\n    load IML from file at `path`\n/anguilla/save path\n    save IML to file at `path`\n\nan additional segment in a route is the name of an IML instance which\nit will target, e.g. /anguilla/add/myinstance\n</code></pre> Source code in <code>src/anguilla/app/server.py</code> <pre><code>def main(\n    osc_port:int=8732,\n    osc_return_port:Optional[int]=None,\n    osc_host:str='',\n    ):\n    \"\"\"\n    Args:\n        osc_port: listen for OSC controls on this port\n        osc_return_port: if supplied, reply on a different port than osc_port\n        osc_host: leave this as empty string to get all traffic on the port\n\n    OSC Routes:\n\n        /anguilla/config \"emb\" \"Identity\"\n            set embedding to Identity (the default)\n        /anguilla/config \"emb\" \"ProjectAndSort\"\n            set embedding to ProjectAndSort\n\n        /anguilla/config \"interp\" \"Smooth\"\n            set interpolator to Smooth (the default)\n        /anguilla/config \"interp\" \"Softmax\"\n            set interpolator to Softmax\n        /anguilla/config \"interp\" \"Ripple\"\n            set interpolator to Ripple\n\n        /anguilla/add \"input\" ... \"output\"... \n            add a point to the mapping\n\n        /anguilla/remove id \n            remove a point from the mapping by ID\n\n        /anguilla/remove_near \"input\" ... [\"k\" k]\n            remove k points from the mapping by proximity\n\n        /anguilla/map \"input\" ... [\"k\" k] [\"ripple\" r] [\"temp\" t]\n            map an input to an output using k neighbors\n            \"temp\" 1 &gt; t &gt; 0 when using Softmax interpolator\n            \"ripple\" r &gt; 0 when using Ripple interpolator\n\n        /anguilla/reset\n            remove all points\n        /anguilla/reset \"keep_near\" ... [\"k\" k]\n            remove all points except the k neighbors of \"keep_near\"\n\n        /anguilla/load path\n            load IML from file at `path`\n        /anguilla/save path\n            save IML to file at `path`\n\n        an additional segment in a route is the name of an IML instance which\n        it will target, e.g. /anguilla/add/myinstance\n    \"\"\"\n    osc = OSC(osc_host, osc_port)\n\n    instances = {}\n    configs = defaultdict(dict)\n\n    @osc.handle('/anguilla/config*')\n    def _(address, **kw):\n        k = get_handle(address)\n\n        print(k)\n        # TODO: validate input\n        configs[k].update(kw)\n        print(configs[k]) \n\n    @osc.handle('/anguilla/add*')\n    def _(address, input:Splat[None], output:Splat[None], id:int=None):\n        key = get_handle(address)\n\n        # d = len(input)\n        # config['feature_size'] = d\n        if key not in instances:\n            # print(f'new IML object with Input dimension {d}')\n            print(f'new IML object with handle \"{key}\" with config {configs[key]}')\n            instances[key] = IML(**configs[key])\n\n        return '/return'+address, instances[key].add(input, output, id=id)\n\n    @osc.handle('/anguilla/remove*')\n    def _(address, id:int):\n        key = get_handle(address)\n        if key in instances:\n            instances[key].remove(id)\n        else:\n            print(f'ERROR: anguilla: {address}: no instance \"{key}\" exists')\n\n    @osc.handle('/anguilla/remove_near*')\n    def _(address, input:Splat[None], k:int=None):\n        key = get_handle(address)\n        if key not in instances:\n            print(f'ERROR: anguilla: {address}: no instance \"{key}\" exists')\n            return\n\n        instances[key].remove_near(input, k=k)\n\n    @osc.handle('/anguilla/map*', return_port=osc_return_port)\n    def _(address, input:Splat[None], k:int=None, **kw):\n        key = get_handle(address)\n        if key not in instances:\n            print(f'ERROR: anguilla: {address}: no instance \"{key}\" exists')\n            print(f'ERROR: anguilla: call {address.replace(\"map\", \"add\")} at least once before {address}')\n            return\n\n        # print(f'{kw=}')\n        result = instances[key].map(input, k=k, **kw).tolist()\n\n        return '/return'+address, *result\n\n    @osc.handle('/anguilla/reset*')\n    def _(address, keep_near:Splat[None]=None, k:int=None):\n        key = get_handle(address)\n        if key not in instances:\n            print(f'ERROR: anguilla: {address}: no instance \"{key}\" exists')\n            return\n\n        instances[key].reset(keep_near, k=k)\n\n    @osc.handle('/anguilla/load*')\n    def _(address, path:str):\n        k = get_handle(address)\n\n        assert path.endswith('.json'), \\\n            \"ERROR: anguilla: path should end with .json\"\n\n        if k=='':\n            print(f'loading all IML objects from {path}')\n            d = anguilla.serialize.load(path)\n            assert isinstance(d, dict)\n            print(f'found IML instances: {list(d.keys())}')\n            instances.update(d)\n        else:\n            print(f'load IML object at \"{k}\" from {path}')\n            instances[k] = IML.load(path)\n\n    @osc.handle('/anguilla/save*')\n    def _(address, path:str):\n        k = get_handle(address)\n        if k!='' and k not in instances:\n            print(f'ERROR: anguilla: {address}: no instance \"{k}\" exists')\n            return\n\n        assert path.endswith('.json'), \\\n            \"ERROR: anguilla: path should end with .json\"\n\n        if k=='':\n            print(f'saving all IML objects to {path}')\n            anguilla.serialize.save(path, instances)\n        else:\n            print(f'saving IML object at \"{k}\" to {path}')\n            instances[k].save(path)\n</code></pre>"}]}