{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"anguilla","text":""},{"location":"#anguilla","title":"anguilla","text":"<p>a package for interactive machine learning</p>"},{"location":"reference/anguilla/__init__/","title":"init","text":""},{"location":"reference/anguilla/__init__/#anguilla.IML","title":"<code>IML</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>class IML(serialize.JSONSerializable):\n\n    def __init__(self, \n            feature_size:Optional[int]=None, \n            emb:Union[str,embed.Embedding]=None, \n            interp:Union[str,interpolate.Interpolate]=None,\n            index:nnsearch.Index=None,\n            k:int=10,\n            verbose=False):\n        \"\"\"\n        Args:\n            feature_size: dimension of feature vectors\n            embed: instance or name of Feature subclass (defaults to Identity)\n            interp: instance or name of Interpolate subclass (defaults to Smooth)\n            index: instance of Index (defaults to IndexBrute)\n            k: default k-nearest neighbors (can be overridden later)\n        \"\"\"\n        self.verbose = verbose\n        # Feature converts Inputs to Features\n        if emb is None:\n            emb = embed.Identity(feature_size)\n        elif isinstance(emb, str):\n            emb = getattr(embed, emb)(feature_size)\n        elif isinstance(emb, embed.Embedding):\n            pass\n        else:\n            raise ValueError\n\n         # Interpolate combines a set of Outputs according to their Scores\n        if interp is None:\n            interp = interpolate.Smooth()\n        elif isinstance(interp, str):\n            interp = getattr(interpolate, interp)()\n        elif isinstance(interp, interpolate.Interpolate):\n            pass\n        else:\n            raise ValueError\n\n        # Index determines the distance metric and efficiency\n        if index is None:\n            index = nnsearch.IndexBrute(emb.size)\n\n        super().__init__(\n            feature_size=feature_size, \n            emb=emb, interp=interp, index=index,\n            k=k)\n\n        self.interpolate = interp\n        self.embed = emb\n        self.neighbors = nnsearch.NNSearch(index, k=k)\n        self.reset()\n\n    def reset(self, keep_near:Input=None, k:int=None):\n        \"\"\"delete all data\n        Args:\n            keep_near: don't remove the neighbors of this input\n            k: number of neighbors for above\n        \"\"\"\n        print('reset')\n        res = None\n        if keep_near is not None and len(self.pairs)&gt;0:\n            if len(keep_near)!=len(self.pairs[0][0]):\n                print('ERROR: iml: keep_near should be an Input vector')\n                keep_near = None\n            else:\n                print('searching neighbors for keep_near')\n                res = self.search(keep_near, k=k)\n\n        self.pairs: Dict[PairID, IOPair] = {}\n        # NNSearch converts feature to output IDs and scores\n        self.neighbors.reset()\n\n        if res is not None:\n            print(f'restoring {len(res.ids)} neighbors')\n            for id,inp,out in zip(res.ids, res.inputs, res.outputs):\n                self.add(inp,out,id=id)\n\n    def add(self, \n            input: Input, \n            output: Output, \n            id: Optional[PairID]=None\n            ) -&gt; PairID:\n        \"\"\"Add a data point to the mapping.\n        Args:\n            input: Input item\n            output: Output item\n            id: PairID to use; if an existing id, replace the point\n        Returns:\n            id: id of the new data point if you need to reference it later\n        \"\"\"\n        if self.verbose: print(f'add {input=}, {output=}')\n        feature = self.embed(input)\n        id = self.neighbors.add(feature, id)\n        # track the mapping from output IDs back to outputs\n        self.pairs[id] = IOPair(input, output)\n        return id\n\n    def get(self, id:PairID) -&gt; IOPair:\n        \"\"\"look up an Input/Output pair by ID\"\"\"\n        try:\n            return self.pairs[id]\n        except Exception:\n            print(\"NNSearch: WARNING: can't `get` ID which doesn't exist or has been removed\")\n\n    def remove(self, ids:Union[PairID, PairIDs]):\n        \"\"\"Remove from mapping by ID(s)\n        \"\"\"\n        # iterable of ids case:\n        if hasattr(ids, '__len__'):\n            for id in ids:\n                self.remove(id)\n        # single id case:\n        else:\n            try:\n                del self.pairs[ids]\n            except Exception:\n                print(f\"IML: WARNING: can't `remove` ID {ids} which doesn't exist or has already been removed\")\n            self.neighbors.remove(ids)\n\n    def remove_near(self, input:Input, k:int=None):\n        \"\"\"Remove from mapping by proximity to Input\n        \"\"\"\n        feature = self.embed(input)\n        self.neighbors.remove_near(feature)\n\n    def search(self, input:Input, k:int=None) -&gt; SearchResult:\n        \"\"\"find k-nearest neighbors\n        Args:\n            input: input item\n            k: max number of neighbors\n        Returns:\n            inputs: neighboring Inputs\n            outputs: corresponding Outputs\n            ids: ids of Input/Output pairs\n            scores: dissimilarity Scores\n        \"\"\"\n        feature = self.embed(input)\n        ids, scores = self.neighbors(feature, k=k)\n        # handle case where there are fewer than k neighbors\n        if not len(ids):\n            raise RuntimeError('no points in mapping. add some!')\n        inputs, outputs = zip(*(self.pairs[i] for i in ids))\n\n        # TODO: text-mode visualize scores\n        # s = ' '*len(self.pairs)\n\n        return SearchResult(inputs, outputs, ids, scores)\n\n    def map(self, input:Input, k:int=None, **kw) -&gt; Output:\n        \"\"\"convert an Input to an Output using search + interpolate\n\n        Args:\n            input: input\n            k: max neighbors\n            **kw: additional arguments are passed to interpolate\n        Returns:\n            output instance\n        \"\"\"\n        # print(f'map {input=}')\n        _, outputs, _, scores = self.search(input, k)\n        result = self.interpolate(outputs, scores, **kw)\n\n        return result\n\n    def save_state(self):\n        \"\"\"return dataset from this IML object.\n        Returns:\n            state: data in this IML object\n        \"\"\"\n        return {\n            'pairs': self.pairs\n        }\n\n    def load_state(self, state):\n        \"\"\"load dataset into this IML object.\n        Args:\n            state: data as obtained from `save_state`\n        \"\"\"\n        for id,pair in state['pairs'].items():\n            self.add(*pair, id=PairID(id))        \n\n    def save(self, path:str):\n        \"\"\"serialize the whole IML object to JSON\n        Args:\n            path: path to JSON file\n        \"\"\"\n        serialize.save(path, self)\n\n    @classmethod\n    def load(cls, path):\n        \"\"\"deserialize a new IML object from JSON\n        Args:\n            path: path to JSON file\n        Returns:\n            new IML instance\n        \"\"\"\n        inst = serialize.load(path)\n        assert isinstance(inst, cls), type(inst)\n        return inst\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.__init__","title":"<code>__init__(feature_size=None, emb=None, interp=None, index=None, k=10, verbose=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>feature_size</code> <code>Optional[int]</code> <p>dimension of feature vectors</p> <code>None</code> <code>embed</code> <p>instance or name of Feature subclass (defaults to Identity)</p> required <code>interp</code> <code>Union[str, Interpolate]</code> <p>instance or name of Interpolate subclass (defaults to Smooth)</p> <code>None</code> <code>index</code> <code>Index</code> <p>instance of Index (defaults to IndexBrute)</p> <code>None</code> <code>k</code> <code>int</code> <p>default k-nearest neighbors (can be overridden later)</p> <code>10</code> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def __init__(self, \n        feature_size:Optional[int]=None, \n        emb:Union[str,embed.Embedding]=None, \n        interp:Union[str,interpolate.Interpolate]=None,\n        index:nnsearch.Index=None,\n        k:int=10,\n        verbose=False):\n    \"\"\"\n    Args:\n        feature_size: dimension of feature vectors\n        embed: instance or name of Feature subclass (defaults to Identity)\n        interp: instance or name of Interpolate subclass (defaults to Smooth)\n        index: instance of Index (defaults to IndexBrute)\n        k: default k-nearest neighbors (can be overridden later)\n    \"\"\"\n    self.verbose = verbose\n    # Feature converts Inputs to Features\n    if emb is None:\n        emb = embed.Identity(feature_size)\n    elif isinstance(emb, str):\n        emb = getattr(embed, emb)(feature_size)\n    elif isinstance(emb, embed.Embedding):\n        pass\n    else:\n        raise ValueError\n\n     # Interpolate combines a set of Outputs according to their Scores\n    if interp is None:\n        interp = interpolate.Smooth()\n    elif isinstance(interp, str):\n        interp = getattr(interpolate, interp)()\n    elif isinstance(interp, interpolate.Interpolate):\n        pass\n    else:\n        raise ValueError\n\n    # Index determines the distance metric and efficiency\n    if index is None:\n        index = nnsearch.IndexBrute(emb.size)\n\n    super().__init__(\n        feature_size=feature_size, \n        emb=emb, interp=interp, index=index,\n        k=k)\n\n    self.interpolate = interp\n    self.embed = emb\n    self.neighbors = nnsearch.NNSearch(index, k=k)\n    self.reset()\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.add","title":"<code>add(input, output, id=None)</code>","text":"<p>Add a data point to the mapping. Args:     input: Input item     output: Output item     id: PairID to use; if an existing id, replace the point Returns:     id: id of the new data point if you need to reference it later</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def add(self, \n        input: Input, \n        output: Output, \n        id: Optional[PairID]=None\n        ) -&gt; PairID:\n    \"\"\"Add a data point to the mapping.\n    Args:\n        input: Input item\n        output: Output item\n        id: PairID to use; if an existing id, replace the point\n    Returns:\n        id: id of the new data point if you need to reference it later\n    \"\"\"\n    if self.verbose: print(f'add {input=}, {output=}')\n    feature = self.embed(input)\n    id = self.neighbors.add(feature, id)\n    # track the mapping from output IDs back to outputs\n    self.pairs[id] = IOPair(input, output)\n    return id\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.get","title":"<code>get(id)</code>","text":"<p>look up an Input/Output pair by ID</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def get(self, id:PairID) -&gt; IOPair:\n    \"\"\"look up an Input/Output pair by ID\"\"\"\n    try:\n        return self.pairs[id]\n    except Exception:\n        print(\"NNSearch: WARNING: can't `get` ID which doesn't exist or has been removed\")\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>deserialize a new IML object from JSON Args:     path: path to JSON file Returns:     new IML instance</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>@classmethod\ndef load(cls, path):\n    \"\"\"deserialize a new IML object from JSON\n    Args:\n        path: path to JSON file\n    Returns:\n        new IML instance\n    \"\"\"\n    inst = serialize.load(path)\n    assert isinstance(inst, cls), type(inst)\n    return inst\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.load_state","title":"<code>load_state(state)</code>","text":"<p>load dataset into this IML object. Args:     state: data as obtained from <code>save_state</code></p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def load_state(self, state):\n    \"\"\"load dataset into this IML object.\n    Args:\n        state: data as obtained from `save_state`\n    \"\"\"\n    for id,pair in state['pairs'].items():\n        self.add(*pair, id=PairID(id))        \n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.map","title":"<code>map(input, k=None, **kw)</code>","text":"<p>convert an Input to an Output using search + interpolate</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Input</code> <p>input</p> required <code>k</code> <code>int</code> <p>max neighbors</p> <code>None</code> <code>**kw</code> <p>additional arguments are passed to interpolate</p> <code>{}</code> <p>Returns:     output instance</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def map(self, input:Input, k:int=None, **kw) -&gt; Output:\n    \"\"\"convert an Input to an Output using search + interpolate\n\n    Args:\n        input: input\n        k: max neighbors\n        **kw: additional arguments are passed to interpolate\n    Returns:\n        output instance\n    \"\"\"\n    # print(f'map {input=}')\n    _, outputs, _, scores = self.search(input, k)\n    result = self.interpolate(outputs, scores, **kw)\n\n    return result\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.remove","title":"<code>remove(ids)</code>","text":"<p>Remove from mapping by ID(s)</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def remove(self, ids:Union[PairID, PairIDs]):\n    \"\"\"Remove from mapping by ID(s)\n    \"\"\"\n    # iterable of ids case:\n    if hasattr(ids, '__len__'):\n        for id in ids:\n            self.remove(id)\n    # single id case:\n    else:\n        try:\n            del self.pairs[ids]\n        except Exception:\n            print(f\"IML: WARNING: can't `remove` ID {ids} which doesn't exist or has already been removed\")\n        self.neighbors.remove(ids)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.remove_near","title":"<code>remove_near(input, k=None)</code>","text":"<p>Remove from mapping by proximity to Input</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def remove_near(self, input:Input, k:int=None):\n    \"\"\"Remove from mapping by proximity to Input\n    \"\"\"\n    feature = self.embed(input)\n    self.neighbors.remove_near(feature)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.reset","title":"<code>reset(keep_near=None, k=None)</code>","text":"<p>delete all data Args:     keep_near: don't remove the neighbors of this input     k: number of neighbors for above</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def reset(self, keep_near:Input=None, k:int=None):\n    \"\"\"delete all data\n    Args:\n        keep_near: don't remove the neighbors of this input\n        k: number of neighbors for above\n    \"\"\"\n    print('reset')\n    res = None\n    if keep_near is not None and len(self.pairs)&gt;0:\n        if len(keep_near)!=len(self.pairs[0][0]):\n            print('ERROR: iml: keep_near should be an Input vector')\n            keep_near = None\n        else:\n            print('searching neighbors for keep_near')\n            res = self.search(keep_near, k=k)\n\n    self.pairs: Dict[PairID, IOPair] = {}\n    # NNSearch converts feature to output IDs and scores\n    self.neighbors.reset()\n\n    if res is not None:\n        print(f'restoring {len(res.ids)} neighbors')\n        for id,inp,out in zip(res.ids, res.inputs, res.outputs):\n            self.add(inp,out,id=id)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.save","title":"<code>save(path)</code>","text":"<p>serialize the whole IML object to JSON Args:     path: path to JSON file</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def save(self, path:str):\n    \"\"\"serialize the whole IML object to JSON\n    Args:\n        path: path to JSON file\n    \"\"\"\n    serialize.save(path, self)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.save_state","title":"<code>save_state()</code>","text":"<p>return dataset from this IML object. Returns:     state: data in this IML object</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def save_state(self):\n    \"\"\"return dataset from this IML object.\n    Returns:\n        state: data in this IML object\n    \"\"\"\n    return {\n        'pairs': self.pairs\n    }\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.search","title":"<code>search(input, k=None)</code>","text":"<p>find k-nearest neighbors Args:     input: input item     k: max number of neighbors Returns:     inputs: neighboring Inputs     outputs: corresponding Outputs     ids: ids of Input/Output pairs     scores: dissimilarity Scores</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def search(self, input:Input, k:int=None) -&gt; SearchResult:\n    \"\"\"find k-nearest neighbors\n    Args:\n        input: input item\n        k: max number of neighbors\n    Returns:\n        inputs: neighboring Inputs\n        outputs: corresponding Outputs\n        ids: ids of Input/Output pairs\n        scores: dissimilarity Scores\n    \"\"\"\n    feature = self.embed(input)\n    ids, scores = self.neighbors(feature, k=k)\n    # handle case where there are fewer than k neighbors\n    if not len(ids):\n        raise RuntimeError('no points in mapping. add some!')\n    inputs, outputs = zip(*(self.pairs[i] for i in ids))\n\n    # TODO: text-mode visualize scores\n    # s = ' '*len(self.pairs)\n\n    return SearchResult(inputs, outputs, ids, scores)\n</code></pre>"},{"location":"reference/anguilla/embed/","title":"Embed","text":""},{"location":"reference/anguilla/embed/#anguilla.embed.Identity","title":"<code>Identity</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>For fixed-length vector data: just check size and convert to numpy array</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class Identity(Embedding):\n    \"\"\"For fixed-length vector data: just check size and convert to numpy array\"\"\"\n    def __init__(self, size):\n        \"\"\"size is both the Input and Feature size\"\"\"\n        super().__init__(size=size)\n        self.size = self.input_size = size\n\n    def __call__(self, source):\n        source, = np_coerce(source)\n        if self.size is not None:\n            assert source.shape[-1] == self.size, (source.shape, self.size)\n        return source\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Identity.__init__","title":"<code>__init__(size)</code>","text":"<p>size is both the Input and Feature size</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __init__(self, size):\n    \"\"\"size is both the Input and Feature size\"\"\"\n    super().__init__(size=size)\n    self.size = self.input_size = size\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.ProjectAndSort","title":"<code>ProjectAndSort</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>for point cloud-like data. use with L2 distance to compute sliced optimal transport.</p> <p>if an Input is a 2D array [B x C], B being the batch dimension (order not meaningful) and C being the coordinate dimension (order meaningful)</p> <p>e.g. [ [x0,y0,z0], [x1,y1,z1], [x2,y2,z2], [x3,y3,z3], ] would be a cloud of B=4 points in C=3 dimensional space</p> <p>This computes <code>n</code> pseudo-random projections down to 1-dimensional spaces, sorts along those lines, and then concatenates to make one feature vector. the L2 distance between feature vectors is the sliced OT distance between point clouds.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class ProjectAndSort(Embedding):\n    \"\"\"\n    for point cloud-like data.\n    use with L2 distance to compute sliced optimal transport.\n\n    if an Input is a 2D array [B x C],\n    B being the batch dimension (order not meaningful)\n    and C being the coordinate dimension (order meaningful)\n\n    e.g.\n    [\n    [x0,y0,z0],\n    [x1,y1,z1],\n    [x2,y2,z2],\n    [x3,y3,z3],\n    ]\n    would be a cloud of B=4 points in C=3 dimensional space\n\n    This computes `n` pseudo-random projections down to 1-dimensional spaces,\n    sorts along those lines,\n    and then concatenates to make one feature vector.\n    the L2 distance between feature vectors is the sliced OT distance between point clouds.\n    \"\"\"\n    def __init__(self, input_size:Tuple[int,int]=None, n:int=16):\n        \"\"\"\n        Args:\n            input_size: input shape [B,C]; if None, lazy init on first __call__\n            n: number of random projections.\n        \"\"\"\n        super().__init__(input_size=input_size, n=n)\n        assert len(input_size)==2, \"ProjectAndSort expects fixed-size 2D array data\"\n\n        self.n = n\n        if input_size is not None:\n            self.init(input_size)\n        else:\n            self.input_size = None\n\n    def init(self, input_size):\n        self.input_size = tuple(input_size)\n\n        self.size = input_size[0] * self.n\n\n        proj = np.random.randn(input_size[1], self.n)\n        proj = proj / np.linalg.norm(proj, axis=0, keepdims=True)\n        self.proj = proj\n\n    def __call__(self, source):\n        source, = np_coerce(source)\n        if self.input_size is None:\n            # lazy init\n            self.init(source.shape[-2:])\n        else:\n            assert source.shape[-2:] == self.input_size, (source.shape, self.input_size)\n\n        # project coordinate dimension to n lines\n        feat = source @ self.proj\n        # sort along the lines\n        feat = np.sort(feat, axis=-2)\n        # flatten\n        # feat = feat.T\n        feat = feat.reshape((*feat.shape[:-2], -1))\n\n        return feat / np.sqrt(self.size)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.ProjectAndSort.__init__","title":"<code>__init__(input_size=None, n=16)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>input_size</code> <code>Tuple[int, int]</code> <p>input shape [B,C]; if None, lazy init on first call</p> <code>None</code> <code>n</code> <code>int</code> <p>number of random projections.</p> <code>16</code> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __init__(self, input_size:Tuple[int,int]=None, n:int=16):\n    \"\"\"\n    Args:\n        input_size: input shape [B,C]; if None, lazy init on first __call__\n        n: number of random projections.\n    \"\"\"\n    super().__init__(input_size=input_size, n=n)\n    assert len(input_size)==2, \"ProjectAndSort expects fixed-size 2D array data\"\n\n    self.n = n\n    if input_size is not None:\n        self.init(input_size)\n    else:\n        self.input_size = None\n</code></pre>"},{"location":"reference/anguilla/interpolate/","title":"Interpolate","text":""},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Interpolate","title":"<code>Interpolate</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> <p>Interpolate combines a set of Outputs weighted by similarity scores.</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Interpolate(JSONSerializable):\n    \"\"\"\n    Interpolate combines a set of Outputs weighted by similarity scores.\n    \"\"\"\n    def __init__(self, **kw):\n        super().__init__(**kw)\n\n    def __call__(self, targets: List[Output], scores: Scores) -&gt; Output:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Mean","title":"<code>Mean</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>mean of neighbors (piecewise constant mapping)</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Mean(Interpolate):\n    \"\"\"mean of neighbors (piecewise constant mapping)\"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets, scores):\n        return sum(targets) / len(targets)\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Ripple","title":"<code>Ripple</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>like Smooth but with high-frequency ripples outside the input domain.</p> <p>works well for making random mappings in high dimensional spaces / bootstrapping expressive mappings from a few points.</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Ripple(Interpolate):\n    \"\"\"like Smooth but with high-frequency ripples outside the input domain.\n\n    works well for making random mappings in high dimensional spaces / bootstrapping expressive mappings from a few points.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets, scores, ripple=1, ripple_depth=1, eps=1e-9):\n        targets, scores = np_coerce(targets, scores)\n\n        scores = scores + eps\n        assert np.min(scores) &gt; 0\n\n        # largest scores -&gt; 0 weight\n        # zero score -&gt; inf weight\n        mx = np.max(scores)\n        weights = 1/scores + (-3*mx*mx + 3*mx*scores - scores*scores)/(mx**3)\n        weights = weights * 2**(\n            ripple_depth * \n            (1+np.cos(np.pi*scores/mx)*np.sin(scores*np.pi*ripple))\n            )\n\n        weights = weights + eps\n        weights = weights / weights.sum()\n\n        result = (np.moveaxis(targets,0,-1)*weights).sum(-1)\n\n        return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Smooth","title":"<code>Smooth</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>non-discontinuous (for k &gt; 2)</p> <p>tries to prevent discontinuities while preserving the input-output mapping exactly where close to data points.</p> <p>works well with larger k. out-of-domain input areas tend to be averages of many outputs.</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Smooth(Interpolate):\n    \"\"\"non-discontinuous (for k &gt; 2)\n\n    tries to prevent discontinuities while preserving the input-output mapping\n    exactly where close to data points.\n\n    works well with larger k.\n    out-of-domain input areas tend to be averages of many outputs.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets, scores, eps=1e-9):#, smooth=False):\n        targets, scores = np_coerce(targets, scores)\n\n        scores = scores + eps\n        assert np.min(scores) &gt; 0\n\n        # largest scores -&gt; 0 weight\n        # zero score -&gt; inf weight\n        # zero first/second derivative at largest score\n        mx = np.max(scores)\n        weights = 1/scores + (-3*mx*mx + 3*mx*scores - scores*scores)/(mx**3)\n\n        weights = weights + eps\n        weights = weights / weights.sum()\n\n        result = (np.moveaxis(targets,0,-1)*weights).sum(-1)\n\n        return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Softmax","title":"<code>Softmax</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>mean weighted toward the nearest neighbors.</p> <p>when k is small, has discontinuities when temp is large, tends to average out nearby points -&gt; tends to get 'washed out' for larger k / larger temp</p> <p>when temp is small, acts more like voronoi cells</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Softmax(Interpolate):\n    \"\"\"mean weighted toward the nearest neighbors.\n\n    when k is small, has discontinuities\n    when temp is large, tends to average out nearby points\n    -&gt; tends to get 'washed out' for larger k / larger temp\n\n    when temp is small, acts more like voronoi cells\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets, scores, temp=0.5):\n        \"\"\"\n        Args:\n            targets: size [K x ...output_dims...] list or ndarray\n            scores: size [K] list or ndarray\n        \"\"\"\n        targets, scores = np_coerce(targets, scores)\n        # print(targets.shape, scores.shape)\n\n        if temp==0:\n            result = targets[np.argmin(scores)]\n        else:\n            centered = scores - np.mean(scores) # for numerical precision\n            logits = np.maximum(-centered/temp, -20)\n            # print(f'{logits=}')\n            if np.max(np.abs(logits)) &gt; 80:\n                result = targets[np.argmin(scores)]\n            else:\n                weights = np.exp(logits)\n                # print(f'{weights=}')\n                weights /= weights.sum()\n                # print(f'{weights=}')\n                result = (np.moveaxis(targets,0,-1)*weights).sum(-1)\n        # print(f'{result=}')\n        return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Softmax.__call__","title":"<code>__call__(targets, scores, temp=0.5)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>targets</code> <p>size [K x ...output_dims...] list or ndarray</p> required <code>scores</code> <p>size [K] list or ndarray</p> required Source code in <code>src/anguilla/interpolate.py</code> <pre><code>def __call__(self, targets, scores, temp=0.5):\n    \"\"\"\n    Args:\n        targets: size [K x ...output_dims...] list or ndarray\n        scores: size [K] list or ndarray\n    \"\"\"\n    targets, scores = np_coerce(targets, scores)\n    # print(targets.shape, scores.shape)\n\n    if temp==0:\n        result = targets[np.argmin(scores)]\n    else:\n        centered = scores - np.mean(scores) # for numerical precision\n        logits = np.maximum(-centered/temp, -20)\n        # print(f'{logits=}')\n        if np.max(np.abs(logits)) &gt; 80:\n            result = targets[np.argmin(scores)]\n        else:\n            weights = np.exp(logits)\n            # print(f'{weights=}')\n            weights /= weights.sum()\n            # print(f'{weights=}')\n            result = (np.moveaxis(targets,0,-1)*weights).sum(-1)\n    # print(f'{result=}')\n    return result\n</code></pre>"},{"location":"reference/anguilla/nnsearch/","title":"Nnsearch","text":""},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.Index","title":"<code>Index</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> <p>base Index class. currently no function besides typing, warning of unimplemented features.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class Index(JSONSerializable):\n    \"\"\"base Index class.\n    currently no function besides typing, warning of unimplemented features.\n    \"\"\"\n    def add(self, feature:Feature, id:Optional[PairID]=None):\n        raise NotImplementedError\n    def remove(self, id:PairID):\n        raise NotImplementedError\n    def get(self, id:PairID):\n        raise NotImplementedError\n    def search(self, feature:Feature, k:int) -&gt; Tuple[Scores, PairIDs]:\n        raise NotImplementedError\n    def reset(self):\n        raise NotImplementedError\n    @property\n    def ids(self):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute","title":"<code>IndexBrute</code>","text":"<p>             Bases: <code>Index</code></p> <p>Optimized for simplicity and flexibility, may not scale to large datasets</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class IndexBrute(Index):\n    \"\"\"\n    Optimized for simplicity and flexibility,\n    may not scale to large datasets\n    \"\"\"\n    def __init__(self, d:int=None, metric:Callable=None):\n        \"\"\"\n        Args:\n            d: optional, dimension of feature\n            metric: distance metric, default to squared euclidean\n        \"\"\"\n        if metric is None:\n            metric = sqL2()\n\n        super().__init__(d=d, metric=metric)\n        self.d = d\n        self.metric = metric\n\n        self.reset()\n\n    def add(self, feature:Feature, id:Optional[PairID]=None) -&gt; PairID:\n        \"\"\"add a new feature, return its ID.\n        Args:\n            feature: the feature to add\n            id: if not supplied, generate a new ID;\n                otherwise, use the supplied id.\n                supply an existing id to replace.\n        \"\"\"\n        if id is None:\n            id = max(self.data, default=-1) + 1\n        self.data[id] = feature\n        return id\n\n    def remove(self, id:PairID):\n        \"\"\"remove a feature by ID\"\"\"\n        del self.data[id]\n\n    def get(self, id:PairID) -&gt; Feature:\n        \"\"\"get a feature by ID\"\"\"\n        return self.data[id]\n\n    def search(self, feature:Feature, k:int=3) -&gt; Tuple[PairIDs, Scores]:\n        \"\"\"get feature(s) and IDs by proximity\"\"\"\n        if not len(self.data):\n            return [], []\n        dist_id = sorted((self.metric(feature, v),k) for k,v in self.data.items())\n        scores, ids = zip(*dist_id[:k])\n        return ids, scores\n\n    def reset(self):\n        self.data:Dict[PairID, Feature] = {}\n\n    @property\n    def ids(self):\n        return self.data.keys()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.__init__","title":"<code>__init__(d=None, metric=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>d</code> <code>int</code> <p>optional, dimension of feature</p> <code>None</code> <code>metric</code> <code>Callable</code> <p>distance metric, default to squared euclidean</p> <code>None</code> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __init__(self, d:int=None, metric:Callable=None):\n    \"\"\"\n    Args:\n        d: optional, dimension of feature\n        metric: distance metric, default to squared euclidean\n    \"\"\"\n    if metric is None:\n        metric = sqL2()\n\n    super().__init__(d=d, metric=metric)\n    self.d = d\n    self.metric = metric\n\n    self.reset()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.add","title":"<code>add(feature, id=None)</code>","text":"<p>add a new feature, return its ID. Args:     feature: the feature to add     id: if not supplied, generate a new ID;         otherwise, use the supplied id.         supply an existing id to replace.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def add(self, feature:Feature, id:Optional[PairID]=None) -&gt; PairID:\n    \"\"\"add a new feature, return its ID.\n    Args:\n        feature: the feature to add\n        id: if not supplied, generate a new ID;\n            otherwise, use the supplied id.\n            supply an existing id to replace.\n    \"\"\"\n    if id is None:\n        id = max(self.data, default=-1) + 1\n    self.data[id] = feature\n    return id\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.get","title":"<code>get(id)</code>","text":"<p>get a feature by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def get(self, id:PairID) -&gt; Feature:\n    \"\"\"get a feature by ID\"\"\"\n    return self.data[id]\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.remove","title":"<code>remove(id)</code>","text":"<p>remove a feature by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove(self, id:PairID):\n    \"\"\"remove a feature by ID\"\"\"\n    del self.data[id]\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.search","title":"<code>search(feature, k=3)</code>","text":"<p>get feature(s) and IDs by proximity</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def search(self, feature:Feature, k:int=3) -&gt; Tuple[PairIDs, Scores]:\n    \"\"\"get feature(s) and IDs by proximity\"\"\"\n    if not len(self.data):\n        return [], []\n    dist_id = sorted((self.metric(feature, v),k) for k,v in self.data.items())\n    scores, ids = zip(*dist_id[:k])\n    return ids, scores\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast","title":"<code>IndexFast</code>","text":"<p>             Bases: <code>Index</code></p> <p>Optimized for fast <code>search</code> on large vectors / datasets. Only L2 distance supported.  <code>remove</code> may be slow.</p> <p>This is currently a wrapper around faiss.FlatIndexL2 which provides stable ids when using <code>remove</code>. In the future could support dot product and/or approximate search indices.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class IndexFast(Index):\n    \"\"\"\n    Optimized for fast `search` on large vectors / datasets.\n    Only L2 distance supported. \n    `remove` may be slow.\n\n    This is currently a wrapper around faiss.FlatIndexL2 which provides stable ids when using `remove`.\n    In the future could support dot product and/or approximate search indices.\n    \"\"\"\n    def __init__(self, d:int, metric:Callable=sqL2):\n        \"\"\"\n        Args:\n            d: dimension of feature\n            metric: \n        \"\"\"\n        super().__init__(d=d, metric=metric)\n        if metric==sqL2:\n            self.index = IndexFlatL2(d)\n        else:\n            raise ValueError(\"\"\"IndexFast supports only sqL2 metric\"\"\")\n        self.metric = metric\n        self.reset()\n\n    @property\n    def d(self):\n        return self.index.d\n\n    def add(self, feature:Feature, id:Optional[PairID]=None):\n        \"\"\"add a new feature, return its ID.\n        Args:\n            feature: the feature to add\n            id: if not supplied, generate a new ID;\n                otherwise, use the supplied id.\n                supply an existing id to replace.\n        \"\"\"\n        if id is None:\n            # no id supplied case\n            id = max(self.id_to_idx, default=-1) + 1\n        elif id in self.id_to_idx:\n            # existing id supplied case\n            self.remove(id)\n        feature = feature[None].astype(np.float32)\n        self.index.add(feature)\n        idx = self.index.ntotal - 1\n        # map ID to faiss index\n        self.id_to_idx[id] = idx\n        self.idx_to_id[idx] = id\n        return id\n\n    def remove(self, id:PairID):\n        \"\"\"remove a feature by ID\"\"\"\n        idx = self.id_to_idx[id]\n        self.index.remove_ids(np.array(idx)[None])\n        del self.id_to_idx[id]\n        del self.idx_to_id[idx]\n        # faiss shifts its internal index to stay dense\n        self.id_to_idx = {\n            k:(v-1 if v &gt; idx else v) for k,v in self.id_to_idx.items()}\n        self.idx_to_id = {\n            (k-1 if k &gt; idx else k):v for k,v in self.idx_to_id.items()}\n\n    def get(self, id:PairID):\n        \"\"\"get a feature by ID\"\"\"\n        idx = self.id_to_idx[id]\n        return self.index.reconstruct(idx)\n\n    def search(self, feature:Feature, k:int=3) -&gt; Tuple[PairIDs, Scores]:\n        \"\"\"get feature(s) and IDs by proximity\"\"\"\n        feature = feature[None].astype(np.float32) \n        scores, idxs = self.index.search(feature, k)\n        # remove batch dim\n        scores, idxs = scores[0], idxs[0]\n        # remove -1 ids\n        b = [i&gt;=0 for i in idxs] \n        scores, idxs = scores[b], idxs[b]\n        # map back to ids\n        ids = [self.idx_to_id[i] for i in idxs]\n        return ids, scores  \n\n    def reset(self):\n        self.index.reset()\n        self.idx_to_id:Dict[int, PairID] = {}\n        self.id_to_idx:Dict[PairID, int] = {}\n\n    @property\n    def ids(self):\n        return self.id_to_idx.keys()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.__init__","title":"<code>__init__(d, metric=sqL2)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>d</code> <code>int</code> <p>dimension of feature</p> required <code>metric</code> <code>Callable</code> <code>sqL2</code> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __init__(self, d:int, metric:Callable=sqL2):\n    \"\"\"\n    Args:\n        d: dimension of feature\n        metric: \n    \"\"\"\n    super().__init__(d=d, metric=metric)\n    if metric==sqL2:\n        self.index = IndexFlatL2(d)\n    else:\n        raise ValueError(\"\"\"IndexFast supports only sqL2 metric\"\"\")\n    self.metric = metric\n    self.reset()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.add","title":"<code>add(feature, id=None)</code>","text":"<p>add a new feature, return its ID. Args:     feature: the feature to add     id: if not supplied, generate a new ID;         otherwise, use the supplied id.         supply an existing id to replace.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def add(self, feature:Feature, id:Optional[PairID]=None):\n    \"\"\"add a new feature, return its ID.\n    Args:\n        feature: the feature to add\n        id: if not supplied, generate a new ID;\n            otherwise, use the supplied id.\n            supply an existing id to replace.\n    \"\"\"\n    if id is None:\n        # no id supplied case\n        id = max(self.id_to_idx, default=-1) + 1\n    elif id in self.id_to_idx:\n        # existing id supplied case\n        self.remove(id)\n    feature = feature[None].astype(np.float32)\n    self.index.add(feature)\n    idx = self.index.ntotal - 1\n    # map ID to faiss index\n    self.id_to_idx[id] = idx\n    self.idx_to_id[idx] = id\n    return id\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.get","title":"<code>get(id)</code>","text":"<p>get a feature by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def get(self, id:PairID):\n    \"\"\"get a feature by ID\"\"\"\n    idx = self.id_to_idx[id]\n    return self.index.reconstruct(idx)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.remove","title":"<code>remove(id)</code>","text":"<p>remove a feature by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove(self, id:PairID):\n    \"\"\"remove a feature by ID\"\"\"\n    idx = self.id_to_idx[id]\n    self.index.remove_ids(np.array(idx)[None])\n    del self.id_to_idx[id]\n    del self.idx_to_id[idx]\n    # faiss shifts its internal index to stay dense\n    self.id_to_idx = {\n        k:(v-1 if v &gt; idx else v) for k,v in self.id_to_idx.items()}\n    self.idx_to_id = {\n        (k-1 if k &gt; idx else k):v for k,v in self.idx_to_id.items()}\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.search","title":"<code>search(feature, k=3)</code>","text":"<p>get feature(s) and IDs by proximity</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def search(self, feature:Feature, k:int=3) -&gt; Tuple[PairIDs, Scores]:\n    \"\"\"get feature(s) and IDs by proximity\"\"\"\n    feature = feature[None].astype(np.float32) \n    scores, idxs = self.index.search(feature, k)\n    # remove batch dim\n    scores, idxs = scores[0], idxs[0]\n    # remove -1 ids\n    b = [i&gt;=0 for i in idxs] \n    scores, idxs = scores[b], idxs[b]\n    # map back to ids\n    ids = [self.idx_to_id[i] for i in idxs]\n    return ids, scores  \n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch","title":"<code>NNSearch</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> <p>This class is the mid-level interface for neighbor search, providing some common utilities over the Index subclasses. Users will generally use <code>IML.search</code> instead of calling NNSearch directly.</p> possibly get rid of this class and fold it into IML? <ul> <li>currently adds only complexity to the IML implementation</li> <li>but could be useful if needing NNSearch without Feature/Interpolate?</li> </ul> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class NNSearch(JSONSerializable):\n    \"\"\"\n    This class is the mid-level interface for neighbor search,\n    providing some common utilities over the Index subclasses.\n    Users will generally use `IML.search` instead of calling NNSearch directly.\n\n    TODO: possibly get rid of this class and fold it into IML?\n        * currently adds only complexity to the IML implementation\n        * but could be useful if needing NNSearch without Feature/Interpolate?\n    \"\"\"\n    def __init__(self, index:Index, k=10):\n        \"\"\"\n        Args:\n            index: instance of Index\n            k: default k-nearest neighbors (but can be overridden later)\n        \"\"\"\n        super().__init__(index=index, k=k)\n        self.index = index\n        self.default_k = k\n\n    def __call__(self, feature:Feature, k:int=None) -&gt; Tuple[PairIDs, Scores]:\n        \"\"\"\n        find the k-nearest neighbors of `feature`\n        Args:\n            feature: query feature vector\n            k: maximum number of neighbors to return\n        Returns:\n            ids: ids of neighbors\n            scores: similarity scores of neighbors (higher is more similar)\n        \"\"\"\n        k = k or self.default_k\n        return self.index.search(feature, k)\n\n    def distance(self, a:Feature, b:Feature):\n        \"\"\"compute distance between two features\"\"\"\n        return self.index.metric(a, b)\n\n    def add(self, feature: Feature, id:Optional[PairID]=None) -&gt; PairID:\n        \"\"\"add a feature vector to the index and return its ID\"\"\"\n        return self.index.add(feature, id)\n\n    def get(self, id:PairID) -&gt; Feature:\n        \"\"\"look up a feature by ID\"\"\"\n        try:\n            return self.index.get(id)\n        except Exception:\n            print(f\"NNSearch: WARNING: can't `get` ID {id} which doesn't exist or has been removed\")\n\n    def remove(self, ids: Union[PairID, PairIDs]):\n        \"\"\"\n        Remove point(s) from the index by ID\n        \"\"\"\n        # iterable of ids case:\n        if hasattr(ids, '__len__'):\n            for id in ids:\n                self.remove(id)\n        # single id case:\n        else:\n            try:\n                self.index.remove(ids)\n            except Exception:\n                print(f\"NNSearch: WARNING: can't `remove` ID {ids} which doesn't exist or has already been removed\")\n\n    def remove_near(self, feature:Feature, k:int=None) -&gt; PairIDs:\n        \"\"\"\n        Remove point(s) from the index by proximity.\n        Use k=1 to remove a single point.\n        \"\"\"\n        k = k or self.default_k\n        ids, _ = self(feature, k=k)\n        self.remove(ids)\n        return ids\n\n    def reset(self):\n        \"\"\"clear all data from the index\"\"\"\n        self.index.reset()\n\n    def __iter__(self):\n        \"\"\"iterate over IDs in the index\"\"\"\n        return iter(self.index.ids)\n\n    def items(self) -&gt; Generator[IDFeaturePair, None, None]:\n        \"\"\"iterate over ID, Feature pairs\"\"\"\n        def iterator():\n            for id in self.index.ids:\n                yield IDFeaturePair(id, self.index.get(id))\n        return iterator()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.__call__","title":"<code>__call__(feature, k=None)</code>","text":"<p>find the k-nearest neighbors of <code>feature</code> Args:     feature: query feature vector     k: maximum number of neighbors to return Returns:     ids: ids of neighbors     scores: similarity scores of neighbors (higher is more similar)</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __call__(self, feature:Feature, k:int=None) -&gt; Tuple[PairIDs, Scores]:\n    \"\"\"\n    find the k-nearest neighbors of `feature`\n    Args:\n        feature: query feature vector\n        k: maximum number of neighbors to return\n    Returns:\n        ids: ids of neighbors\n        scores: similarity scores of neighbors (higher is more similar)\n    \"\"\"\n    k = k or self.default_k\n    return self.index.search(feature, k)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.__init__","title":"<code>__init__(index, k=10)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>index</code> <code>Index</code> <p>instance of Index</p> required <code>k</code> <p>default k-nearest neighbors (but can be overridden later)</p> <code>10</code> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __init__(self, index:Index, k=10):\n    \"\"\"\n    Args:\n        index: instance of Index\n        k: default k-nearest neighbors (but can be overridden later)\n    \"\"\"\n    super().__init__(index=index, k=k)\n    self.index = index\n    self.default_k = k\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.__iter__","title":"<code>__iter__()</code>","text":"<p>iterate over IDs in the index</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __iter__(self):\n    \"\"\"iterate over IDs in the index\"\"\"\n    return iter(self.index.ids)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.add","title":"<code>add(feature, id=None)</code>","text":"<p>add a feature vector to the index and return its ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def add(self, feature: Feature, id:Optional[PairID]=None) -&gt; PairID:\n    \"\"\"add a feature vector to the index and return its ID\"\"\"\n    return self.index.add(feature, id)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.distance","title":"<code>distance(a, b)</code>","text":"<p>compute distance between two features</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def distance(self, a:Feature, b:Feature):\n    \"\"\"compute distance between two features\"\"\"\n    return self.index.metric(a, b)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.get","title":"<code>get(id)</code>","text":"<p>look up a feature by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def get(self, id:PairID) -&gt; Feature:\n    \"\"\"look up a feature by ID\"\"\"\n    try:\n        return self.index.get(id)\n    except Exception:\n        print(f\"NNSearch: WARNING: can't `get` ID {id} which doesn't exist or has been removed\")\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.items","title":"<code>items()</code>","text":"<p>iterate over ID, Feature pairs</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def items(self) -&gt; Generator[IDFeaturePair, None, None]:\n    \"\"\"iterate over ID, Feature pairs\"\"\"\n    def iterator():\n        for id in self.index.ids:\n            yield IDFeaturePair(id, self.index.get(id))\n    return iterator()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.remove","title":"<code>remove(ids)</code>","text":"<p>Remove point(s) from the index by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove(self, ids: Union[PairID, PairIDs]):\n    \"\"\"\n    Remove point(s) from the index by ID\n    \"\"\"\n    # iterable of ids case:\n    if hasattr(ids, '__len__'):\n        for id in ids:\n            self.remove(id)\n    # single id case:\n    else:\n        try:\n            self.index.remove(ids)\n        except Exception:\n            print(f\"NNSearch: WARNING: can't `remove` ID {ids} which doesn't exist or has already been removed\")\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.remove_near","title":"<code>remove_near(feature, k=None)</code>","text":"<p>Remove point(s) from the index by proximity. Use k=1 to remove a single point.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove_near(self, feature:Feature, k:int=None) -&gt; PairIDs:\n    \"\"\"\n    Remove point(s) from the index by proximity.\n    Use k=1 to remove a single point.\n    \"\"\"\n    k = k or self.default_k\n    ids, _ = self(feature, k=k)\n    self.remove(ids)\n    return ids\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.NNSearch.reset","title":"<code>reset()</code>","text":"<p>clear all data from the index</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def reset(self):\n    \"\"\"clear all data from the index\"\"\"\n    self.index.reset()\n</code></pre>"},{"location":"reference/anguilla/serialize/","title":"Serialize","text":""},{"location":"reference/anguilla/serialize/#anguilla.serialize.JSONSerializable","title":"<code>JSONSerializable</code>","text":"<p>JSON serialization for Python classes. Saves keyword arguments at construction, and also any state returned by the <code>save_state</code> method.</p> <p>to make class a serializable, subclass JSONSerializable,  and in the constructor use e.g. <code>super().__init__(a=0, b=1 ...)</code> with any keyword args which should be serialized.</p> <p>override <code>save_state</code> and <code>load_state</code> to handle any mutable state.</p> <p>Constructor args and return values of <code>save_state</code> can be other JSONSerializable objects.</p> Source code in <code>src/anguilla/serialize.py</code> <pre><code>class JSONSerializable:\n    \"\"\"JSON serialization for Python classes.\n    Saves keyword arguments at construction,\n    and also any state returned by the `save_state` method.\n\n    to make class a serializable, subclass JSONSerializable, \n    and in the constructor use e.g. `super().__init__(a=0, b=1 ...)`\n    with any keyword args which should be serialized.\n\n    override `save_state` and `load_state` to handle any mutable state.\n\n    Constructor args and return values of `save_state` can be other JSONSerializable objects.\n    \"\"\"\n    def __init__(self, **kw):\n        self._kw = deepcopy(kw)\n        self._kw['__inst__'] = '.'.join((\n            self.__class__.__module__,\n            self.__class__.__name__))\n\n    def _store(self):\n        return {'__state__': self.save_state(), **self._kw}\n\n    def save_state(self):\n        \"\"\"return object state in JSON serializable form\"\"\"\n        return None\n\n    def load_state(self, state):\n        \"\"\"restore from de-serialized state\"\"\"\n        pass\n</code></pre>"},{"location":"reference/anguilla/serialize/#anguilla.serialize.JSONSerializable.load_state","title":"<code>load_state(state)</code>","text":"<p>restore from de-serialized state</p> Source code in <code>src/anguilla/serialize.py</code> <pre><code>def load_state(self, state):\n    \"\"\"restore from de-serialized state\"\"\"\n    pass\n</code></pre>"},{"location":"reference/anguilla/serialize/#anguilla.serialize.JSONSerializable.save_state","title":"<code>save_state()</code>","text":"<p>return object state in JSON serializable form</p> Source code in <code>src/anguilla/serialize.py</code> <pre><code>def save_state(self):\n    \"\"\"return object state in JSON serializable form\"\"\"\n    return None\n</code></pre>"},{"location":"reference/anguilla/types/","title":"Types","text":""},{"location":"reference/anguilla/app/__init__/","title":"init","text":""},{"location":"reference/anguilla/app/server/","title":"Server","text":"Authors <p>Victor Shepardson Intelligent Instruments Lab 2023</p>"},{"location":"reference/anguilla/app/server/#anguilla.app.server.main","title":"<code>main(osc_port=8732, osc_return_port=None, osc_host='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>osc_port</code> <code>int</code> <p>listen for OSC controls on this port</p> <code>8732</code> <code>osc_return_port</code> <code>Optional[int]</code> <p>if supplied, reply on a different port than osc_port</p> <code>None</code> <code>osc_host</code> <code>str</code> <p>leave this as empty string to get all traffic on the port</p> <code>''</code> <p>OSC Routes:</p> <pre><code>/anguilla/config/emb \"Identity\"\n    set embedding to Identity (the default)\n/anguilla/config/emb \"ProjectAndSort\"\n    set embedding to ProjectAndSort\n\n/anguilla/config/interp \"Smooth\"\n    set interpolator to Smooth (the default)\n/anguilla/config/interp \"Softmax\"\n    set interpolator to Softmax\n/anguilla/config/interp \"Ripple\"\n    set interpolator to Ripple\n\n-- or --\n/anguilla/config \"emb\" ... \"interp\" ...\n\n/anguilla/add \"input\" ... \"output\"... \n    add a point to the mapping\n\n/anguilla/remove id \n    remove a point from the mapping by ID\n\n/anguilla/remove_near \"input\" ... [\"k\" k]\n    remove k points from the mapping by proximity\n\n/anguilla/map \"input\" ... [\"k\" k] [\"ripple\" r] [\"temp\" t]\n    map an input to an output using k neighbors\n    \"temp\" 1 &gt; t &gt; 0 when using Softmax interpolator\n    \"ripple\" r &gt; 0 when using Ripple interpolator\n\n/anguilla/reset\n    remove all points\n/anguilla/reset \"keep_near\" ... [\"k\" k]\n    remove all points except the k neighbors of \"keep_near\"\n\n/anguilla/load path\n    load IML from file at `path`\n/anguilla/save path\n    save IML to file at `path`\n</code></pre> Source code in <code>src/anguilla/app/server.py</code> <pre><code>def main(\n    osc_port:int=8732,\n    osc_return_port:Optional[int]=None,\n    osc_host:str='',\n    ):\n    \"\"\"\n    Args:\n        osc_port: listen for OSC controls on this port\n        osc_return_port: if supplied, reply on a different port than osc_port\n        osc_host: leave this as empty string to get all traffic on the port\n\n    OSC Routes:\n\n        /anguilla/config/emb \"Identity\"\n            set embedding to Identity (the default)\n        /anguilla/config/emb \"ProjectAndSort\"\n            set embedding to ProjectAndSort\n\n        /anguilla/config/interp \"Smooth\"\n            set interpolator to Smooth (the default)\n        /anguilla/config/interp \"Softmax\"\n            set interpolator to Softmax\n        /anguilla/config/interp \"Ripple\"\n            set interpolator to Ripple\n\n        -- or --\n        /anguilla/config \"emb\" ... \"interp\" ...\n\n        /anguilla/add \"input\" ... \"output\"... \n            add a point to the mapping\n\n        /anguilla/remove id \n            remove a point from the mapping by ID\n\n        /anguilla/remove_near \"input\" ... [\"k\" k]\n            remove k points from the mapping by proximity\n\n        /anguilla/map \"input\" ... [\"k\" k] [\"ripple\" r] [\"temp\" t]\n            map an input to an output using k neighbors\n            \"temp\" 1 &gt; t &gt; 0 when using Softmax interpolator\n            \"ripple\" r &gt; 0 when using Ripple interpolator\n\n        /anguilla/reset\n            remove all points\n        /anguilla/reset \"keep_near\" ... [\"k\" k]\n            remove all points except the k neighbors of \"keep_near\"\n\n        /anguilla/load path\n            load IML from file at `path`\n        /anguilla/save path\n            save IML to file at `path`\n    \"\"\"\n    osc = OSC(osc_host, osc_port)\n\n    instances = {}\n    configs = defaultdict(dict)\n\n    @osc.kwargs('/anguilla/config/*')\n    def _(address, **kw):\n        k = address.split('config')[-1]\n        # TODO: validate input\n        configs[k].update(kw)\n        print(configs[k]) \n\n    # @osc.args('/anguilla/config/interp')\n    # def _(address, name):\n    #     if iml is None:\n    #         config['interp'] = name\n    #     else:\n    #         iml.set_interp(name)\n\n    # @osc.args('/anguilla/config/emb')\n    # def _(address, name):\n    #     if iml is None:\n    #         config['emb'] = name\n    #     else:\n    #         iml.set_emb(name)\n\n    @osc.args('/anguilla/add*')\n    def _(address, *a):\n        k = ''.join(address.split('/')[3:]).strip('/')\n\n        kw = vector_args(a)\n\n        if 'input' not in kw:\n            print('ERROR: anguilla: no input vector supplied')\n            return\n        if 'output' not in kw:\n            print('ERROR: anguilla: no output vector supplied')\n            return\n\n        # d = len(kw['input'])\n        # config['feature_size'] = d\n        if k not in instances:\n            # print(f'new IML object with Input dimension {d}')\n            print(f'new IML object with handle \"{k}\" with config {configs[k]}')\n            instances[k] = IML(**configs[k])\n\n        return '/return'+address, instances[k].add(**kw)\n\n    @osc.args('/anguilla/remove*')\n    def _(address, id):\n        k = ''.join(address.split('/')[3:]).strip('/')\n        if k in instances:\n            instances[k].remove(id)\n        else:\n            print(f'ERROR: anguilla: {address}: no instance \"{k}\" exists')\n\n    @osc.args('/anguilla/remove_near*')\n    def _(address, *a):\n        k = ''.join(address.split('/')[3:]).strip('/')\n        if k not in instances:\n            print(f'ERROR: anguilla: {address}: no instance \"{k}\" exists')\n            return\n\n        kw = vector_args(a, scalars=['k'])\n\n        if 'input' not in kw:\n            print(f'ERROR: anguilla: {address}: no input vector supplied')\n            return\n\n        instances[k].remove_near(**kw)\n\n    @osc.args('/anguilla/map*', return_port=osc_return_port)\n    def _(address, *a):\n        k = ''.join(address.split('/')[3:]).strip('/')\n        if k not in instances:\n            print(f'ERROR: anguilla: {address}: no instance \"{k}\" exists')\n            print('ERROR: anguilla: call /anguilla/add at least once before /map')\n            return\n\n        kw = vector_args(a, scalars=['k', 'temp', 'ripple'])\n\n        if 'input' not in kw:\n            print('ERROR: anguilla: no input vector supplied')\n            return\n\n        result = instances[k].map(**kw).tolist()\n\n        return '/return'+address, *result\n\n    @osc.args('/anguilla/reset*')\n    def _(address, *a):\n        k = ''.join(address.split('/')[3:]).strip('/')\n        if k not in instances:\n            print(f'ERROR: anguilla: {address}: no instance \"{k}\" exists')\n            return\n\n        kw = vector_args(a, scalars=['k'])\n\n        instances[k].reset(**kw)\n\n    @osc.args('/anguilla/load*')\n    def _(address, path):\n        k = ''.join(address.split('/')[3:]).strip('/')\n        assert isinstance(path, str)\n        assert path.endswith('.json'), \\\n            \"ERROR: anguilla: path should end with .json\"\n        if k=='':\n            print(f'loading all IML objects from {path}')\n            d = anguilla.serialize.load(path)\n            assert isinstance(d, dict)\n            print(f'found IML instances: {list(d.keys())}')\n            instances.update(d)\n        else:\n            print(f'load IML object at \"{k}\" from {path}')\n            instances[k] = IML.load(path)\n\n    @osc.args('/anguilla/save*')\n    def _(address, path):\n        k = ''.join(address.split('/')[3:]).strip('/')\n        if k!='' and k not in instances:\n            print(f'ERROR: anguilla: {address}: no instance \"{k}\" exists')\n            return\n\n        assert isinstance(path, str)\n        assert path.endswith('.json'), \\\n            \"ERROR: anguilla: path should end with .json\"\n\n        if k=='':\n            print(f'saving all IML objects to {path}')\n            anguilla.serialize.save(path, instances)\n        else:\n            print(f'saving IML object at \"{k}\" to {path}')\n            instances[k].save(path)\n</code></pre>"}]}