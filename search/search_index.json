{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"anguilla","text":""},{"location":"#anguilla-documentation","title":"anguilla (Documentation)","text":"<p><code>anguilla</code> is a mapping and interactive machine learning package for digital musical instrument design in Python.</p> <p>This is an early stage project. Currently, the main interface is the <code>IML</code> class, which allows adding input-output pairs (<code>IML.add</code>) and subsequently mapping points in the input space to outputs (<code>IML.map</code>). </p> <p><code>anguilla</code> is designed to be modular and hackable. An <code>IML</code> object is composed of several exchangeable parts:</p> <ul> <li>an <code>Embedding</code> embeds input points into a feature space</li> <li>an <code>NNSearch</code> implements nearest-neighbor search in the feature space</li> <li>an <code>Interpolate</code> combines a set of output points using the distances of their corresponding input points from a neighboring query point.</li> </ul> <p><code>anguilla server</code> will expose the Python API over Open Sound Control (OSC) using iipyper.</p> <p>For examples and tutorials of how to use <code>anguilla</code>, see our examples repo (TBC).</p>"},{"location":"#install","title":"Install","text":"<p><code>anguilla</code> can be installed from PyPI:</p> <pre><code>pip install anguilla-iml\n</code></pre>"},{"location":"#with-pytorch","title":"with pytorch","text":"<p>If you encounter an incompatibility between the PyPI versions of pytorch and faiss-cpu, try installing them both from conda (<code>conda install -c pytorch pytorch faiss-cpu</code>) before <code>pip install anguilla-iml</code>.</p>"},{"location":"#develop","title":"Develop","text":"<p>See the iil-dev repo for a recommended dev environment. </p> <p>It's also possible to develop <code>anguilla</code> in isolation. You will need Poetry and your Python environment manager of choice. With <code>conda</code>, for example:</p> <pre><code>conda create -n anguilla-env python=3.10 poetry\nconda activate anguilla-env\n</code></pre> <p>then:</p> <pre><code>git clone git@github.com:Intelligent-Instruments-Lab/anguilla.git\ncd anguilla\npoetry install\n</code></pre>"},{"location":"#contact","title":"Contact","text":"<p><code>anguilla</code> is developed by the Intelligent Instruments Lab. Get in touch to collaborate:</p> <p>\u25e6 iil.is \u25e6  Facebook \u25e6  Instagram \u25e6  X (Twitter) \u25e6  YouTube \u25e6  Discord \u25e6  GitHub \u25e6  LinkedIn \u25e6  Email \u25e6 </p>"},{"location":"#funding","title":"Funding","text":"<p>The Intelligent Instruments project (INTENT) is funded by the European Research Council (ERC) under the European Union\u2019s Horizon 2020 research and innovation programme (Grant agreement No. 101001848).</p>"},{"location":"reference/anguilla/__init__/","title":"init","text":""},{"location":"reference/anguilla/__init__/#anguilla.IML","title":"<code>IML</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>class IML(serialize.JSONSerializable):\n    def __init__(self, \n            embed_input:Union[str,embed.Embedding]=None, \n            embed_output:Union[str,embed.Embedding]=None, \n            interpolate:Union[str,interpolate.Interpolate]=None,\n            index:nnsearch.Index=None,\n            verbose=False):\n        \"\"\"\n        Args:\n            embed_input: instance, type or name of Feature subclass \n                (defaults to Identity)\n            embed_output: instance, type or name of Feature subclass \n                (defaults to Identity). must be invertible.\n            interp: instance, type or name of Interpolate subclass \n                (defaults to Smooth)\n            index: instance, type or name of Index subclass \n                (defaults to IndexFast)\n        \"\"\"\n        self.verbose = verbose\n        # Feature converts Inputs to Features\n        self.embed_input = construct(\n            embed_input, _embed, Embedding, Identity)\n        self.embed_output = construct(\n            embed_output, _embed, Embedding, Identity)\n        self.interpolate = construct(\n            interpolate, _interpolate, Interpolate, Smooth)\n        self.index = construct(\n            index, _nnsearch, Index, IndexFast)\n\n        super().__init__(\n            embed_input=self.embed_input, embed_output=self.embed_output, \n            interpolate=self.interpolate, index=self.index)\n\n        self.seq_reset()\n        self.reset()\n\n    def reset(self, keep_near:Input=None, k:int=None):\n        \"\"\"\n        delete all data\n\n        Args:\n            keep_near: don't remove the neighbors of this input\n            k: number of neighbors for above\n        \"\"\"\n        print('reset')\n        res = None\n        if keep_near is not None and len(self.pairs)&gt;0:\n            if len(keep_near)!=len(self.pairs[0][0]):\n                print('ERROR: iml: keep_near should be an Input vector')\n                keep_near = None\n            else:\n                print('searching neighbors for keep_near')\n                res = self.search(keep_near, k=k)\n\n        self.pairs: Dict[PairID, IOPair] = {}\n\n        self.index.reset()\n\n        if res is not None:\n            print(f'restoring {len(res.ids)} neighbors')\n            for id,inp,out in zip(res.ids, res.inputs, res.outputs):\n                self.add(inp,out,id=id)\n\n    def embed_batch(self, embedding, inputs:List[Input], inv=False):\n        emb = embedding.inv if inv else embedding\n        if embedding.is_batched:\n            return emb(inputs)\n        else:\n            return np.stack([emb(x) for x in inputs], 0)\n\n    def add_batch(self,\n            inputs: List[Input], \n            outputs: List[Output], \n            ids: Optional[PairIDs]=None,\n            ) -&gt; PairIDs:\n        \"\"\"\n        Add a batch of data points to the mapping.\n\n        Args:\n            input: list of inputs or ndarray with leading batch dimension\n            output:  list of inputs or ndarray with leading batch dimension \n            id: list of PairIDs to use.\n                if any are an existing id, replace those points.\n                if not supplied, ids will be chosen automatically.\n\n        Returns:\n            ids: ids of the new data points if you need to reference them later\n        \"\"\"\n        zs = self.embed_batch(self.embed_input, inputs)\n        ws = self.embed_batch(self.embed_output, outputs)\n        # if either is 1d at this point, it should be a batch of scalars\n        # convert batches of scalars to batches of vectors\n        if zs.ndim==1:\n            zs = zs[:,None]\n        if ws.ndim==1:\n            ws = ws[:,None]\n        ids = self.index.add(zs, ws, ids=ids)\n\n        for x,y,i in zip(inputs, outputs, ids):\n            i = PairID(i)\n            self.pairs[i] = IOPair(x,y)\n\n        return ids\n\n    def add(self, \n            input: Input, \n            output: Output, \n            id: Optional[PairID]=None,\n            batch: bool=False\n            ) -&gt; PairID:\n        \"\"\"\n        Add a data point to the mapping.\n\n        Args:\n            input: Input item\n            output: Output item\n            id: PairID to use; if an existing id, replace the point.\n                if not supplied, id will be chosen automatically.\n            batch: if True, equivalent to `add_batch`\n\n        Returns:\n            id: id of the new data point if you need to reference it later\n        \"\"\"\n        if batch:\n            return self.add_batch(input, output, id)\n        else:\n            id = id if id is None else (id,)\n            return self.add_batch((input,), (output,), id)[0]\n\n    def get(self, id:PairID) -&gt; IOPair:\n        \"\"\"\n        look up an Input/Output pair by ID\n\n        Args:\n            id: ID to look up.\n        \"\"\"\n        try:\n            return self.pairs[id]\n        except Exception:\n            print(\"IML: WARNING: can't `get` ID which doesn't exist or has been removed\")\n\n    def remove_batch(self, ids:PairIDs):\n        self.remove(ids, batch=True)\n\n    def remove(self, id:PairID, batch:bool=None):\n        \"\"\"\n        Remove from mapping by ID(s)\n\n        Args:\n            ids: ID or collection of IDs of points to remove from the mapping.\n            batch: True if removing a batch of ids, False if a single id.\n                will attempt to infer from `id` if not supplied.\n        \"\"\"\n        if batch is None:\n            batch = not isinstance(id, str) and hasattr(id, '__len__')\n\n        ids = id if batch else (id,)\n        for i in ids:\n            try:    \n                del self.pairs[i]\n            except Exception:\n                print(f\"IML: WARNING: can't `remove` ID {i} which doesn't exist or has already been removed\")\n\n        self.index.remove(ids)\n\n    def remove_near(self, input:Input, k:int=None, batch=False) -&gt; PairIDs:\n        \"\"\"\n        Remove from mapping by proximity to Input.\n        \"\"\"\n        if not batch:\n            input = (input,)\n        zs = self.embed_batch(self.embed_input, input)\n        ids = self.index.remove_near(zs, k=k)\n        for i in ids:\n            del self.pairs[i]\n\n    def map_batch(self, inputs:List[Input], k:int=None, **kw) -&gt; List[Output]:\n        \"\"\"convert a batch of Input to batch of Output using search + interpolate\n\n        Args:\n            input: [batch x ...]\n            k: max neighbors\n            **kw: additional arguments are passed to interpolate\n\n        Returns:\n            batch of outputs\n        \"\"\"\n        zs = self.embed_batch(self.embed_input, inputs)\n        _, ws, _, scores = self.index.search(\n            zs, k, return_inputs=False, return_outputs=True, return_ids=False)\n        ws = np.moveaxis(ws,0,1)\n        scores = np.moveaxis(scores,0,1)\n        # print(f'map_batch: {k=} {zs.shape=} {ws.shape=} {scores.shape=}')\n        w = self.interpolate(ws, scores, **kw)\n        return self.embed_batch(self.embed_output, w, inv=True)\n\n    def map(self, input:Input, k:int=None, **kw) -&gt; Output:\n        \"\"\"convert an Input to an Output using search + interpolate\n\n        Args:\n            input: input\n            k: max neighbors\n            **kw: additional arguments are passed to interpolate\n\n        Returns:\n            output\n        \"\"\"\n        return self.map_batch((input,), k, **kw)[0]\n\n    ### prototype feature\n    def seq_reset(self):\n        \"\"\"clear buffered input/output sequences\"\"\"\n        self.seq_in_buffer = []\n        self.seq_out_buffer = []\n\n    def seq_input(self, input:Input):\n        \"\"\"add to the buffered input sequence\"\"\"\n        self.seq_in_buffer.append(input)\n\n    def seq_output(self, output:Output):\n        \"\"\"add to the buffered output sequence\"\"\"\n        self.seq_out_buffer.append(output)\n\n    def seq_end(self, n=100):\n        \"\"\"interpolate the buffered input and output sequences to length n,\n        then add n pairs to the mapping and clear the buffered sequences.\n\n        Does nothing if either buffered sequence is empty.\n\n        Args:\n            n: the number of points to add\n\n        Returns:\n            same as add_batch\n        \"\"\"\n        if self.verbose &gt; 1:\n            print(f\"{len(self.seq_in_buffer)=} {len(self.seq_out_buffer)=}\")\n\n        if not len(self.seq_in_buffer):\n            print(f\"IML: WARNING: calling seq_end with no buffered inputs\")\n            return []\n        if not len(self.seq_out_buffer):\n            print(f\"IML: WARNING: calling seq_end with no buffered outputs\")\n            return []\n\n        coords = np.linspace(0,1,n)\n\n        inputs = CubicSpline(\n            np.linspace(0,1,len(self.seq_in_buffer)), \n            np.array(self.seq_in_buffer)\n            )(coords)\n\n        outputs = CubicSpline(\n            np.linspace(0,1,len(self.seq_out_buffer)), \n            np.array(self.seq_out_buffer)\n            )(coords)\n\n        self.seq_reset()\n\n        return self.add_batch(inputs, outputs)\n\n    def save_state(self):\n        \"\"\"\n        return dataset from this IML object.\n\n        Returns:\n            state: data in this IML object\n        \"\"\"\n        return {\n            'pairs': self.pairs\n        }\n\n    def load_state(self, state):\n        \"\"\"\n        load dataset into this IML object.\n\n        Args:\n            state: data as obtained from `save_state`\n        \"\"\"\n        for id,pair in state['pairs'].items():\n            self.add(*pair, id=PairID(id))        \n\n    def save(self, path:str):\n        \"\"\"\n        serialize the whole IML object to JSON\n\n        Args:\n            path: path to JSON file\n        \"\"\"\n        serialize.save(path, self)\n\n    @classmethod\n    def load(cls, path):\n        \"\"\"\n        deserialize a new IML object from JSON\n\n        Args:\n            path: path to JSON file\n\n        Returns:\n            new IML instance\n        \"\"\"\n        inst = serialize.load(path)\n        assert isinstance(inst, cls), type(inst)\n        return inst\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.__init__","title":"<code>__init__(embed_input=None, embed_output=None, interpolate=None, index=None, verbose=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>embed_input</code> <code>Union[str, Embedding]</code> <p>instance, type or name of Feature subclass  (defaults to Identity)</p> <code>None</code> <code>embed_output</code> <code>Union[str, Embedding]</code> <p>instance, type or name of Feature subclass  (defaults to Identity). must be invertible.</p> <code>None</code> <code>interp</code> <p>instance, type or name of Interpolate subclass  (defaults to Smooth)</p> required <code>index</code> <code>Index</code> <p>instance, type or name of Index subclass  (defaults to IndexFast)</p> <code>None</code> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def __init__(self, \n        embed_input:Union[str,embed.Embedding]=None, \n        embed_output:Union[str,embed.Embedding]=None, \n        interpolate:Union[str,interpolate.Interpolate]=None,\n        index:nnsearch.Index=None,\n        verbose=False):\n    \"\"\"\n    Args:\n        embed_input: instance, type or name of Feature subclass \n            (defaults to Identity)\n        embed_output: instance, type or name of Feature subclass \n            (defaults to Identity). must be invertible.\n        interp: instance, type or name of Interpolate subclass \n            (defaults to Smooth)\n        index: instance, type or name of Index subclass \n            (defaults to IndexFast)\n    \"\"\"\n    self.verbose = verbose\n    # Feature converts Inputs to Features\n    self.embed_input = construct(\n        embed_input, _embed, Embedding, Identity)\n    self.embed_output = construct(\n        embed_output, _embed, Embedding, Identity)\n    self.interpolate = construct(\n        interpolate, _interpolate, Interpolate, Smooth)\n    self.index = construct(\n        index, _nnsearch, Index, IndexFast)\n\n    super().__init__(\n        embed_input=self.embed_input, embed_output=self.embed_output, \n        interpolate=self.interpolate, index=self.index)\n\n    self.seq_reset()\n    self.reset()\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.add","title":"<code>add(input, output, id=None, batch=False)</code>","text":"<p>Add a data point to the mapping.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Input</code> <p>Input item</p> required <code>output</code> <code>Output</code> <p>Output item</p> required <code>id</code> <code>Optional[PairID]</code> <p>PairID to use; if an existing id, replace the point. if not supplied, id will be chosen automatically.</p> <code>None</code> <code>batch</code> <code>bool</code> <p>if True, equivalent to <code>add_batch</code></p> <code>False</code> <p>Returns:</p> Name Type Description <code>id</code> <code>PairID</code> <p>id of the new data point if you need to reference it later</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def add(self, \n        input: Input, \n        output: Output, \n        id: Optional[PairID]=None,\n        batch: bool=False\n        ) -&gt; PairID:\n    \"\"\"\n    Add a data point to the mapping.\n\n    Args:\n        input: Input item\n        output: Output item\n        id: PairID to use; if an existing id, replace the point.\n            if not supplied, id will be chosen automatically.\n        batch: if True, equivalent to `add_batch`\n\n    Returns:\n        id: id of the new data point if you need to reference it later\n    \"\"\"\n    if batch:\n        return self.add_batch(input, output, id)\n    else:\n        id = id if id is None else (id,)\n        return self.add_batch((input,), (output,), id)[0]\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.add_batch","title":"<code>add_batch(inputs, outputs, ids=None)</code>","text":"<p>Add a batch of data points to the mapping.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>list of inputs or ndarray with leading batch dimension</p> required <code>output</code> <p>list of inputs or ndarray with leading batch dimension </p> required <code>id</code> <p>list of PairIDs to use. if any are an existing id, replace those points. if not supplied, ids will be chosen automatically.</p> required <p>Returns:</p> Name Type Description <code>ids</code> <code>PairIDs</code> <p>ids of the new data points if you need to reference them later</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def add_batch(self,\n        inputs: List[Input], \n        outputs: List[Output], \n        ids: Optional[PairIDs]=None,\n        ) -&gt; PairIDs:\n    \"\"\"\n    Add a batch of data points to the mapping.\n\n    Args:\n        input: list of inputs or ndarray with leading batch dimension\n        output:  list of inputs or ndarray with leading batch dimension \n        id: list of PairIDs to use.\n            if any are an existing id, replace those points.\n            if not supplied, ids will be chosen automatically.\n\n    Returns:\n        ids: ids of the new data points if you need to reference them later\n    \"\"\"\n    zs = self.embed_batch(self.embed_input, inputs)\n    ws = self.embed_batch(self.embed_output, outputs)\n    # if either is 1d at this point, it should be a batch of scalars\n    # convert batches of scalars to batches of vectors\n    if zs.ndim==1:\n        zs = zs[:,None]\n    if ws.ndim==1:\n        ws = ws[:,None]\n    ids = self.index.add(zs, ws, ids=ids)\n\n    for x,y,i in zip(inputs, outputs, ids):\n        i = PairID(i)\n        self.pairs[i] = IOPair(x,y)\n\n    return ids\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.get","title":"<code>get(id)</code>","text":"<p>look up an Input/Output pair by ID</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>PairID</code> <p>ID to look up.</p> required Source code in <code>src/anguilla/__init__.py</code> <pre><code>def get(self, id:PairID) -&gt; IOPair:\n    \"\"\"\n    look up an Input/Output pair by ID\n\n    Args:\n        id: ID to look up.\n    \"\"\"\n    try:\n        return self.pairs[id]\n    except Exception:\n        print(\"IML: WARNING: can't `get` ID which doesn't exist or has been removed\")\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>deserialize a new IML object from JSON</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>path to JSON file</p> required <p>Returns:</p> Type Description <p>new IML instance</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>@classmethod\ndef load(cls, path):\n    \"\"\"\n    deserialize a new IML object from JSON\n\n    Args:\n        path: path to JSON file\n\n    Returns:\n        new IML instance\n    \"\"\"\n    inst = serialize.load(path)\n    assert isinstance(inst, cls), type(inst)\n    return inst\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.load_state","title":"<code>load_state(state)</code>","text":"<p>load dataset into this IML object.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>data as obtained from <code>save_state</code></p> required Source code in <code>src/anguilla/__init__.py</code> <pre><code>def load_state(self, state):\n    \"\"\"\n    load dataset into this IML object.\n\n    Args:\n        state: data as obtained from `save_state`\n    \"\"\"\n    for id,pair in state['pairs'].items():\n        self.add(*pair, id=PairID(id))        \n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.map","title":"<code>map(input, k=None, **kw)</code>","text":"<p>convert an Input to an Output using search + interpolate</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Input</code> <p>input</p> required <code>k</code> <code>int</code> <p>max neighbors</p> <code>None</code> <code>**kw</code> <p>additional arguments are passed to interpolate</p> <code>{}</code> <p>Returns:</p> Type Description <code>Output</code> <p>output</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def map(self, input:Input, k:int=None, **kw) -&gt; Output:\n    \"\"\"convert an Input to an Output using search + interpolate\n\n    Args:\n        input: input\n        k: max neighbors\n        **kw: additional arguments are passed to interpolate\n\n    Returns:\n        output\n    \"\"\"\n    return self.map_batch((input,), k, **kw)[0]\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.map_batch","title":"<code>map_batch(inputs, k=None, **kw)</code>","text":"<p>convert a batch of Input to batch of Output using search + interpolate</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>[batch x ...]</p> required <code>k</code> <code>int</code> <p>max neighbors</p> <code>None</code> <code>**kw</code> <p>additional arguments are passed to interpolate</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Output]</code> <p>batch of outputs</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def map_batch(self, inputs:List[Input], k:int=None, **kw) -&gt; List[Output]:\n    \"\"\"convert a batch of Input to batch of Output using search + interpolate\n\n    Args:\n        input: [batch x ...]\n        k: max neighbors\n        **kw: additional arguments are passed to interpolate\n\n    Returns:\n        batch of outputs\n    \"\"\"\n    zs = self.embed_batch(self.embed_input, inputs)\n    _, ws, _, scores = self.index.search(\n        zs, k, return_inputs=False, return_outputs=True, return_ids=False)\n    ws = np.moveaxis(ws,0,1)\n    scores = np.moveaxis(scores,0,1)\n    # print(f'map_batch: {k=} {zs.shape=} {ws.shape=} {scores.shape=}')\n    w = self.interpolate(ws, scores, **kw)\n    return self.embed_batch(self.embed_output, w, inv=True)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.remove","title":"<code>remove(id, batch=None)</code>","text":"<p>Remove from mapping by ID(s)</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <p>ID or collection of IDs of points to remove from the mapping.</p> required <code>batch</code> <code>bool</code> <p>True if removing a batch of ids, False if a single id. will attempt to infer from <code>id</code> if not supplied.</p> <code>None</code> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def remove(self, id:PairID, batch:bool=None):\n    \"\"\"\n    Remove from mapping by ID(s)\n\n    Args:\n        ids: ID or collection of IDs of points to remove from the mapping.\n        batch: True if removing a batch of ids, False if a single id.\n            will attempt to infer from `id` if not supplied.\n    \"\"\"\n    if batch is None:\n        batch = not isinstance(id, str) and hasattr(id, '__len__')\n\n    ids = id if batch else (id,)\n    for i in ids:\n        try:    \n            del self.pairs[i]\n        except Exception:\n            print(f\"IML: WARNING: can't `remove` ID {i} which doesn't exist or has already been removed\")\n\n    self.index.remove(ids)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.remove_near","title":"<code>remove_near(input, k=None, batch=False)</code>","text":"<p>Remove from mapping by proximity to Input.</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def remove_near(self, input:Input, k:int=None, batch=False) -&gt; PairIDs:\n    \"\"\"\n    Remove from mapping by proximity to Input.\n    \"\"\"\n    if not batch:\n        input = (input,)\n    zs = self.embed_batch(self.embed_input, input)\n    ids = self.index.remove_near(zs, k=k)\n    for i in ids:\n        del self.pairs[i]\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.reset","title":"<code>reset(keep_near=None, k=None)</code>","text":"<p>delete all data</p> <p>Parameters:</p> Name Type Description Default <code>keep_near</code> <code>Input</code> <p>don't remove the neighbors of this input</p> <code>None</code> <code>k</code> <code>int</code> <p>number of neighbors for above</p> <code>None</code> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def reset(self, keep_near:Input=None, k:int=None):\n    \"\"\"\n    delete all data\n\n    Args:\n        keep_near: don't remove the neighbors of this input\n        k: number of neighbors for above\n    \"\"\"\n    print('reset')\n    res = None\n    if keep_near is not None and len(self.pairs)&gt;0:\n        if len(keep_near)!=len(self.pairs[0][0]):\n            print('ERROR: iml: keep_near should be an Input vector')\n            keep_near = None\n        else:\n            print('searching neighbors for keep_near')\n            res = self.search(keep_near, k=k)\n\n    self.pairs: Dict[PairID, IOPair] = {}\n\n    self.index.reset()\n\n    if res is not None:\n        print(f'restoring {len(res.ids)} neighbors')\n        for id,inp,out in zip(res.ids, res.inputs, res.outputs):\n            self.add(inp,out,id=id)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.save","title":"<code>save(path)</code>","text":"<p>serialize the whole IML object to JSON</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to JSON file</p> required Source code in <code>src/anguilla/__init__.py</code> <pre><code>def save(self, path:str):\n    \"\"\"\n    serialize the whole IML object to JSON\n\n    Args:\n        path: path to JSON file\n    \"\"\"\n    serialize.save(path, self)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.save_state","title":"<code>save_state()</code>","text":"<p>return dataset from this IML object.</p> <p>Returns:</p> Name Type Description <code>state</code> <p>data in this IML object</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def save_state(self):\n    \"\"\"\n    return dataset from this IML object.\n\n    Returns:\n        state: data in this IML object\n    \"\"\"\n    return {\n        'pairs': self.pairs\n    }\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.seq_end","title":"<code>seq_end(n=100)</code>","text":"<p>interpolate the buffered input and output sequences to length n, then add n pairs to the mapping and clear the buffered sequences.</p> <p>Does nothing if either buffered sequence is empty.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <p>the number of points to add</p> <code>100</code> <p>Returns:</p> Type Description <p>same as add_batch</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def seq_end(self, n=100):\n    \"\"\"interpolate the buffered input and output sequences to length n,\n    then add n pairs to the mapping and clear the buffered sequences.\n\n    Does nothing if either buffered sequence is empty.\n\n    Args:\n        n: the number of points to add\n\n    Returns:\n        same as add_batch\n    \"\"\"\n    if self.verbose &gt; 1:\n        print(f\"{len(self.seq_in_buffer)=} {len(self.seq_out_buffer)=}\")\n\n    if not len(self.seq_in_buffer):\n        print(f\"IML: WARNING: calling seq_end with no buffered inputs\")\n        return []\n    if not len(self.seq_out_buffer):\n        print(f\"IML: WARNING: calling seq_end with no buffered outputs\")\n        return []\n\n    coords = np.linspace(0,1,n)\n\n    inputs = CubicSpline(\n        np.linspace(0,1,len(self.seq_in_buffer)), \n        np.array(self.seq_in_buffer)\n        )(coords)\n\n    outputs = CubicSpline(\n        np.linspace(0,1,len(self.seq_out_buffer)), \n        np.array(self.seq_out_buffer)\n        )(coords)\n\n    self.seq_reset()\n\n    return self.add_batch(inputs, outputs)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.seq_input","title":"<code>seq_input(input)</code>","text":"<p>add to the buffered input sequence</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def seq_input(self, input:Input):\n    \"\"\"add to the buffered input sequence\"\"\"\n    self.seq_in_buffer.append(input)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.seq_output","title":"<code>seq_output(output)</code>","text":"<p>add to the buffered output sequence</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def seq_output(self, output:Output):\n    \"\"\"add to the buffered output sequence\"\"\"\n    self.seq_out_buffer.append(output)\n</code></pre>"},{"location":"reference/anguilla/__init__/#anguilla.IML.seq_reset","title":"<code>seq_reset()</code>","text":"<p>clear buffered input/output sequences</p> Source code in <code>src/anguilla/__init__.py</code> <pre><code>def seq_reset(self):\n    \"\"\"clear buffered input/output sequences\"\"\"\n    self.seq_in_buffer = []\n    self.seq_out_buffer = []\n</code></pre>"},{"location":"reference/anguilla/__version__/","title":"version","text":""},{"location":"reference/anguilla/embed/","title":"Embed","text":""},{"location":"reference/anguilla/embed/#anguilla.embed.Cat","title":"<code>Cat</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>Embedding which applies multiple other embeddings to elements of a sequence, and concatenates the results</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class Cat(Embedding):\n    \"\"\"\n    Embedding which applies multiple other embeddings to elements of a sequence,\n    and concatenates the results\n    \"\"\"\n    def __init__(self, *embs):\n        self.embs = embs\n    def __call__(self, sources):\n        assert len(sources)==len(self.embs)\n        parts = [emb(source) for source, emb in zip(sources, self.embs)]\n        # convert 0d scalars to 1d before cat\n        parts = [p[None] if p.ndim==0 else p for p in parts]\n        return np.concatenate(parts, -1)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Chain","title":"<code>Chain</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>Embedding which applies multiple embeddings in series to the same input</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class Chain(Embedding):\n    \"\"\"\n    Embedding which applies multiple embeddings in series to the same input\n    \"\"\"\n    def __init__(self, *embs):\n        self.embs = embs\n    def __call__(self, source):\n        for emb in self.embs:\n            source = emb(source)\n        return source\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Identity","title":"<code>Identity</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>The most basic Embedding.  Optionally checks size of input vector and ensures it is a numpy array,  but otherwise leaves it unchanged.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class Identity(Embedding):\n    \"\"\"\n    The most basic Embedding. \n    Optionally checks size of input vector and ensures it is a numpy array, \n    but otherwise leaves it unchanged.\n    \"\"\"\n    def __init__(self, size:Optional[int]=None):\n        \"\"\"\n        Args:\n            size: both the Input and the Feature size.\n                if supplied, inputs will be validated to be that size.\n                otherwise, they will just be converted to ndarrays.\n        \"\"\"\n        super().__init__(size=size)\n        self.size = self.input_size = size\n        self.is_batched = True\n        # self.in_type = lambda x:x\n\n    def __call__(self, source) -&gt; ArrayLike:\n        \"\"\"\n        embed the input.\n\n        Args:\n            source: an input sequence\n\n        Returns:\n            feature: the input sequence as a numpy array.\n        \"\"\"\n        # self.in_type = type(source)\n\n        source, = np_coerce(source)\n\n        if self.size is not None:\n            if isinstance(self.size, int):\n                assert source.shape[-1] == self.size, (source.shape, self.size)\n            else:\n                assert source.shape[-len(self.size):] == self.size, (source.shape, self.size)\n        return source\n\n    def inv(self, w):\n        # print(self.in_type, type(w), w.shape)\n        # w = self.in_type(w)\n        return w\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Identity.__call__","title":"<code>__call__(source)</code>","text":"<p>embed the input.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>an input sequence</p> required <p>Returns:</p> Name Type Description <code>feature</code> <code>ArrayLike</code> <p>the input sequence as a numpy array.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __call__(self, source) -&gt; ArrayLike:\n    \"\"\"\n    embed the input.\n\n    Args:\n        source: an input sequence\n\n    Returns:\n        feature: the input sequence as a numpy array.\n    \"\"\"\n    # self.in_type = type(source)\n\n    source, = np_coerce(source)\n\n    if self.size is not None:\n        if isinstance(self.size, int):\n            assert source.shape[-1] == self.size, (source.shape, self.size)\n        else:\n            assert source.shape[-len(self.size):] == self.size, (source.shape, self.size)\n    return source\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Identity.__init__","title":"<code>__init__(size=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>both the Input and the Feature size. if supplied, inputs will be validated to be that size. otherwise, they will just be converted to ndarrays.</p> <code>None</code> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __init__(self, size:Optional[int]=None):\n    \"\"\"\n    Args:\n        size: both the Input and the Feature size.\n            if supplied, inputs will be validated to be that size.\n            otherwise, they will just be converted to ndarrays.\n    \"\"\"\n    super().__init__(size=size)\n    self.size = self.input_size = size\n    self.is_batched = True\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.ProjectAndSort","title":"<code>ProjectAndSort</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>Embedding for point cloud-like data. use with an L2 distance <code>Metric</code> to compute sliced optimal transport.</p> <p>if an Input is a 2D array [B x C], B being the point dimension (order not meaningful) and C being the coordinate dimension (order meaningful)</p> <p>e.g. [ [x0,y0,z0], [x1,y1,z1], [x2,y2,z2], [x3,y3,z3], ] would be a cloud of B=4 points in C=3 dimensional space</p> <p>This computes <code>n</code> pseudo-random projections down to 1-dimensional spaces, sorts along those lines, and then concatenates to make one feature vector. the L2 distance between feature vectors is the sliced OT distance between point clouds.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class ProjectAndSort(Embedding):\n    \"\"\"\n    Embedding for point cloud-like data.\n    use with an L2 distance `Metric` to compute sliced optimal transport.\n\n    if an Input is a 2D array [B x C],\n    B being the point dimension (order not meaningful)\n    and C being the coordinate dimension (order meaningful)\n\n    e.g.\n    [\n    [x0,y0,z0],\n    [x1,y1,z1],\n    [x2,y2,z2],\n    [x3,y3,z3],\n    ]\n    would be a cloud of B=4 points in C=3 dimensional space\n\n    This computes `n` pseudo-random projections down to 1-dimensional spaces,\n    sorts along those lines,\n    and then concatenates to make one feature vector.\n    the L2 distance between feature vectors is the sliced OT distance between point clouds.\n    \"\"\"\n    def __init__(self, input_size:Tuple[int,int]=None, n:int=16, seed:int=0):\n        \"\"\"\n        Args:\n            input_size: input shape [B,C]; if None, lazy init on first __call__\n            n: number of random projections.\n            seed: random seed.\n        \"\"\"\n        super().__init__(input_size=input_size, n=n)\n        self.n = n\n        self.seed = seed\n        self.is_batched = True\n\n        if input_size is not None:\n            self.init(input_size)\n        else:\n            self.input_size = None\n            self.size = None\n\n    def init(self, input_size):\n        assert len(input_size)&gt;=2, \"ProjectAndSort expects at least 2D array data\"\n\n        self.rng = np.random.default_rng(self.seed)\n\n        self.input_size = tuple(input_size)\n\n        self.size = input_size[0] * self.n\n\n        proj = self.rng.normal(size=(input_size[1], self.n))\n        proj = proj / np.linalg.norm(proj, axis=0, keepdims=True)\n        self.proj = proj\n\n    def __call__(self, source) -&gt; ArrayLike:\n        \"\"\"\n        embed the input.\n\n        Args:\n            source: an 2d input sequence of shape [batch x coordinates]     \n                representing a set of points.\n\n        Returns:\n            feature: 1d array of concatenated projections of the input points.\n        \"\"\"\n        source, = np_coerce(source)\n        if self.input_size is None:\n            # lazy init\n            self.init(source.shape[-2:])\n        else:\n            assert source.shape[-2:] == self.input_size, (source.shape, self.input_size)\n\n        # project coordinate dimension to n lines\n        feat = source @ self.proj\n        # sort along the lines\n        feat = np.sort(feat, axis=-2)\n        # flatten\n        # feat = feat.T\n        feat = feat.reshape((*feat.shape[:-2], -1))\n\n        return feat / np.sqrt(self.size)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.ProjectAndSort.__call__","title":"<code>__call__(source)</code>","text":"<p>embed the input.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>an 2d input sequence of shape [batch x coordinates]    representing a set of points.</p> required <p>Returns:</p> Name Type Description <code>feature</code> <code>ArrayLike</code> <p>1d array of concatenated projections of the input points.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __call__(self, source) -&gt; ArrayLike:\n    \"\"\"\n    embed the input.\n\n    Args:\n        source: an 2d input sequence of shape [batch x coordinates]     \n            representing a set of points.\n\n    Returns:\n        feature: 1d array of concatenated projections of the input points.\n    \"\"\"\n    source, = np_coerce(source)\n    if self.input_size is None:\n        # lazy init\n        self.init(source.shape[-2:])\n    else:\n        assert source.shape[-2:] == self.input_size, (source.shape, self.input_size)\n\n    # project coordinate dimension to n lines\n    feat = source @ self.proj\n    # sort along the lines\n    feat = np.sort(feat, axis=-2)\n    # flatten\n    # feat = feat.T\n    feat = feat.reshape((*feat.shape[:-2], -1))\n\n    return feat / np.sqrt(self.size)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.ProjectAndSort.__init__","title":"<code>__init__(input_size=None, n=16, seed=0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>input_size</code> <code>Tuple[int, int]</code> <p>input shape [B,C]; if None, lazy init on first call</p> <code>None</code> <code>n</code> <code>int</code> <p>number of random projections.</p> <code>16</code> <code>seed</code> <code>int</code> <p>random seed.</p> <code>0</code> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __init__(self, input_size:Tuple[int,int]=None, n:int=16, seed:int=0):\n    \"\"\"\n    Args:\n        input_size: input shape [B,C]; if None, lazy init on first __call__\n        n: number of random projections.\n        seed: random seed.\n    \"\"\"\n    super().__init__(input_size=input_size, n=n)\n    self.n = n\n    self.seed = seed\n    self.is_batched = True\n\n    if input_size is not None:\n        self.init(input_size)\n    else:\n        self.input_size = None\n        self.size = None\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Random","title":"<code>Random</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>Pseudo-random uniform embedding in [-1, 1] for any hashable inputs.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class Random(Embedding):\n    \"\"\"\n    Pseudo-random uniform embedding in [-1, 1] for any hashable inputs.\n    \"\"\"\n    def __init__(self, size:int=1):\n        \"\"\"\n        Args:\n            size: the Feature size.\n        \"\"\"\n        super().__init__(size=size)\n        self.input_size = None\n        self.size = size\n\n    def __call__(self, source) -&gt; ArrayLike:\n        \"\"\"\n        embed the input.\n\n        Args:\n            source: a hashable input. cannot be batched.\n\n        Returns:\n            feature: uniformly distributed pseudo-random vector\n        \"\"\"\n        # TODO: treat lists as batches?\n\n        # get 32 bits from the input\n        h = hash(source) &amp; 8589934591\n        rng = np.random.default_rng(h)\n        return rng.random(size=self.size)*2 - 1\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Random.__call__","title":"<code>__call__(source)</code>","text":"<p>embed the input.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>a hashable input. cannot be batched.</p> required <p>Returns:</p> Name Type Description <code>feature</code> <code>ArrayLike</code> <p>uniformly distributed pseudo-random vector</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __call__(self, source) -&gt; ArrayLike:\n    \"\"\"\n    embed the input.\n\n    Args:\n        source: a hashable input. cannot be batched.\n\n    Returns:\n        feature: uniformly distributed pseudo-random vector\n    \"\"\"\n    # TODO: treat lists as batches?\n\n    # get 32 bits from the input\n    h = hash(source) &amp; 8589934591\n    rng = np.random.default_rng(h)\n    return rng.random(size=self.size)*2 - 1\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.Random.__init__","title":"<code>__init__(size=1)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>the Feature size.</p> <code>1</code> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __init__(self, size:int=1):\n    \"\"\"\n    Args:\n        size: the Feature size.\n    \"\"\"\n    super().__init__(size=size)\n    self.input_size = None\n    self.size = size\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.RandomNormal","title":"<code>RandomNormal</code>","text":"<p>             Bases: <code>Embedding</code></p> <p>Pseudo-random Gaussian embedding for any hashable inputs.</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>class RandomNormal(Embedding):\n    \"\"\"\n    Pseudo-random Gaussian embedding for any hashable inputs.\n    \"\"\"\n    def __init__(self, size:int=1):\n        \"\"\"\n        Args:\n            size: the Feature size.\n        \"\"\"\n        super().__init__(size=size)\n        self.input_size = None\n        self.size = size\n\n    def __call__(self, source) -&gt; ArrayLike:\n        \"\"\"\n        embed the input.\n\n        Args:\n            source: an input sequence\n\n        Returns:\n            feature: normally distributed pseudo-random vector\n        \"\"\"\n        # get 32 bits from the input\n        h = hash(source) &amp; 8589934591\n        rng = np.random.default_rng(h)\n        return rng.normal(size=self.size)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.RandomNormal.__call__","title":"<code>__call__(source)</code>","text":"<p>embed the input.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>an input sequence</p> required <p>Returns:</p> Name Type Description <code>feature</code> <code>ArrayLike</code> <p>normally distributed pseudo-random vector</p> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __call__(self, source) -&gt; ArrayLike:\n    \"\"\"\n    embed the input.\n\n    Args:\n        source: an input sequence\n\n    Returns:\n        feature: normally distributed pseudo-random vector\n    \"\"\"\n    # get 32 bits from the input\n    h = hash(source) &amp; 8589934591\n    rng = np.random.default_rng(h)\n    return rng.normal(size=self.size)\n</code></pre>"},{"location":"reference/anguilla/embed/#anguilla.embed.RandomNormal.__init__","title":"<code>__init__(size=1)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>the Feature size.</p> <code>1</code> Source code in <code>src/anguilla/embed.py</code> <pre><code>def __init__(self, size:int=1):\n    \"\"\"\n    Args:\n        size: the Feature size.\n    \"\"\"\n    super().__init__(size=size)\n    self.input_size = None\n    self.size = size\n</code></pre>"},{"location":"reference/anguilla/interpolate/","title":"Interpolate","text":""},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Interpolate","title":"<code>Interpolate</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> <p><code>Interpolate</code> combines a set of <code>Outputs</code> weighted by dissimilarity scores.</p> <p>The scores depend on the <code>Metric</code> used by the <code>NNSearch</code>.  They may be, for example, distances or negative cosine similarities.</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Interpolate(JSONSerializable):\n    \"\"\"\n    `Interpolate` combines a set of `Outputs` weighted by dissimilarity scores.\n\n    The scores depend on the `Metric` used by the `NNSearch`. \n    They may be, for example, distances or negative cosine similarities.\n    \"\"\"\n    def __init__(self, **kw):\n        super().__init__(**kw)\n\n    def __call__(self, targets: List[Output], scores: Scores) -&gt; Output:\n        \"\"\"\n        Args:\n            targets: [k x ...batch dims... x output ]\n                first dimension is neighbor dimension\n                trailing dimensions are feature dimensions\n                remaining dimensions are batch dimensions\n            scores: [k x ...batch dims...]\n\n        Returns:\n            output: [&lt;batch dims&gt; x output]\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Interpolate.__call__","title":"<code>__call__(targets, scores)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>targets</code> <code>List[Output]</code> <p>[k x ...batch dims... x output ] first dimension is neighbor dimension trailing dimensions are feature dimensions remaining dimensions are batch dimensions</p> required <code>scores</code> <code>Scores</code> <p>[k x ...batch dims...]</p> required <p>Returns:</p> Name Type Description <code>output</code> <code>Output</code> <p>[ x output] Source code in <code>src/anguilla/interpolate.py</code> <pre><code>def __call__(self, targets: List[Output], scores: Scores) -&gt; Output:\n    \"\"\"\n    Args:\n        targets: [k x ...batch dims... x output ]\n            first dimension is neighbor dimension\n            trailing dimensions are feature dimensions\n            remaining dimensions are batch dimensions\n        scores: [k x ...batch dims...]\n\n    Returns:\n        output: [&lt;batch dims&gt; x output]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Mean","title":"<code>Mean</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>mean of neighbors (piecewise constant mapping)</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Mean(Interpolate):\n    \"\"\"mean of neighbors (piecewise constant mapping)\"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets, scores):\n        return sum(targets) / len(targets)\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Nearest","title":"<code>Nearest</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>return nearest neighbor (voronoi cell mapping)</p> <p>NOTE: preferable to use <code>Mean</code> with <code>k=1</code> in most cases.</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Nearest(Interpolate):\n    \"\"\"\n    return nearest neighbor (voronoi cell mapping)\n\n    NOTE: preferable to use `Mean` with `k=1` in most cases.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets, scores):\n        # print(f'{scores.shape=}')\n        idx = np.argmin(scores, 0)[None,...,None]\n        # print(f'{idx.shape=} {targets.shape=}')\n        r = np.take_along_axis(targets, idx, 0)[0]\n        # print(f'{r.shape=}')\n        return r\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Ripple","title":"<code>Ripple</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>like <code>Smooth</code> but with high-frequency ripples outside the input domain.</p> <p>useful for making random mappings in high dimensional spaces / bootstrapping expressive mappings from a few points.</p> <p>Equivalent to <code>Nearest</code> if used with <code>k &lt; 3</code></p> <p>Scale-equivariant; the scale of inputs interacts with the <code>ripple</code> frequency.  If input data is scaled by a factor <code>s</code>, scale <code>ripple</code> by <code>1/s</code> to compensate.</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Ripple(Interpolate):\n    \"\"\"\n    like `Smooth` but with high-frequency ripples outside the input domain.\n\n    useful for making random mappings in high dimensional spaces / bootstrapping expressive mappings from a few points.\n\n    Equivalent to `Nearest` if used with `k &lt; 3`\n\n    Scale-equivariant; the scale of inputs interacts with the `ripple` frequency. \n    If input data is scaled by a factor `s`, scale `ripple` by `1/s` to compensate.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, \n            targets:List[Output], scores:List[float], \n            ripple:float=1, ripple_depth:float=1, eps:float=1e-6):\n        \"\"\"\n        Args:\n            targets: size [K x ...output_dims...] list or ndarray\n            scores: size [K] list or ndarray\n            ripple: frequency of ripples\n            ripple_depth: amplitude of ripples\n            eps: small value preventing division by zero\n        \"\"\"\n        if len(scores) &lt; 3:\n            return Nearest()(targets, scores)\n\n        targets, scores = np_coerce(targets, scores)\n\n        scores = scores**0.5\n\n        scores = scores + eps\n        assert np.min(scores) &gt; 0\n\n        # largest scores -&gt; 0 weight\n        # zero score -&gt; inf weight\n        mx = np.max(scores, 0)\n        # weights = 1/scores + (-3*mx*mx + 3*mx*scores - scores*scores)/(mx**3)\n        s_m = scores/mx\n        weights = 1/scores + ((3-s_m)*s_m - 3)/mx \n\n        weights = weights * 2**(\n            ripple_depth * \n            (1+np.cos(2*np.pi/mx*scores)*np.sin(2*np.pi*ripple*scores))\n            )\n\n        weights = weights + eps/mx\n        weights = weights / weights.sum(0)\n\n        result = np.transpose((\n            np.transpose(targets)*np.transpose(weights)).sum(-1))\n\n        return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Ripple.__call__","title":"<code>__call__(targets, scores, ripple=1, ripple_depth=1, eps=1e-06)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>targets</code> <code>List[Output]</code> <p>size [K x ...output_dims...] list or ndarray</p> required <code>scores</code> <code>List[float]</code> <p>size [K] list or ndarray</p> required <code>ripple</code> <code>float</code> <p>frequency of ripples</p> <code>1</code> <code>ripple_depth</code> <code>float</code> <p>amplitude of ripples</p> <code>1</code> <code>eps</code> <code>float</code> <p>small value preventing division by zero</p> <code>1e-06</code> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>def __call__(self, \n        targets:List[Output], scores:List[float], \n        ripple:float=1, ripple_depth:float=1, eps:float=1e-6):\n    \"\"\"\n    Args:\n        targets: size [K x ...output_dims...] list or ndarray\n        scores: size [K] list or ndarray\n        ripple: frequency of ripples\n        ripple_depth: amplitude of ripples\n        eps: small value preventing division by zero\n    \"\"\"\n    if len(scores) &lt; 3:\n        return Nearest()(targets, scores)\n\n    targets, scores = np_coerce(targets, scores)\n\n    scores = scores**0.5\n\n    scores = scores + eps\n    assert np.min(scores) &gt; 0\n\n    # largest scores -&gt; 0 weight\n    # zero score -&gt; inf weight\n    mx = np.max(scores, 0)\n    # weights = 1/scores + (-3*mx*mx + 3*mx*scores - scores*scores)/(mx**3)\n    s_m = scores/mx\n    weights = 1/scores + ((3-s_m)*s_m - 3)/mx \n\n    weights = weights * 2**(\n        ripple_depth * \n        (1+np.cos(2*np.pi/mx*scores)*np.sin(2*np.pi*ripple*scores))\n        )\n\n    weights = weights + eps/mx\n    weights = weights / weights.sum(0)\n\n    result = np.transpose((\n        np.transpose(targets)*np.transpose(weights)).sum(-1))\n\n    return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Smooth","title":"<code>Smooth</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>Interpolate which tries to prevent discontinuities while preserving the  input-output mapping exactly where close to data points.</p> <p>Only works for <code>k &gt; 2</code>, and generally works well with larger <code>k</code>. out-of-domain input areas tend to be averages of many outputs.</p> <p>Equivalent to <code>Nearest</code> if used with <code>k &lt; 3</code>.</p> <p>Scale-invariant, should work the same if inputs are rescaled. (still recommended to keep inputs roughly normalized for numerical stability)</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Smooth(Interpolate):\n    \"\"\"\n    Interpolate which tries to prevent discontinuities while preserving the \n    input-output mapping exactly where close to data points.\n\n    Only works for `k &gt; 2`, and generally works well with larger `k`.\n    out-of-domain input areas tend to be averages of many outputs.\n\n    Equivalent to `Nearest` if used with `k &lt; 3`.\n\n    Scale-invariant, should work the same if inputs are rescaled.\n    (still recommended to keep inputs roughly normalized for numerical stability)\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets:List[Output], scores:List[float], eps:float=1e-6):\n        \"\"\"\n        Args:\n            targets: size [K, ...batch dims..., output dim] \n            scores: size [K, ...batch dims...] \n            eps: small value preventing division by zero\n        \"\"\"\n        if len(scores) &lt; 3:\n            return Nearest()(targets, scores)\n\n        targets, scores = np_coerce(targets, scores)\n\n        scores = scores**0.5\n\n        scores = scores + eps\n        assert np.min(scores) &gt; 0\n\n        # largest scores -&gt; 0 weight\n        # zero score -&gt; inf weight\n        # zero first/second derivative at largest score\n        mx = np.max(scores, 0)\n        # weights = 1/scores + (-3*mx*mx + 3*mx*scores - scores*scores)/(mx**3)\n        # weights = 1/scores + (-3*mx*mx + (3*mx - scores)*scores)/(mx**3)\n        s_m = scores/mx\n        weights = 1/scores + ((3-s_m)*s_m - 3)/mx \n\n        weights = weights + eps/mx\n        weights = weights / weights.sum(0)\n\n        result = np.transpose((\n            np.transpose(targets)*np.transpose(weights)).sum(-1))\n\n        return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Smooth.__call__","title":"<code>__call__(targets, scores, eps=1e-06)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>targets</code> <code>List[Output]</code> <p>size [K, ...batch dims..., output dim] </p> required <code>scores</code> <code>List[float]</code> <p>size [K, ...batch dims...] </p> required <code>eps</code> <code>float</code> <p>small value preventing division by zero</p> <code>1e-06</code> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>def __call__(self, targets:List[Output], scores:List[float], eps:float=1e-6):\n    \"\"\"\n    Args:\n        targets: size [K, ...batch dims..., output dim] \n        scores: size [K, ...batch dims...] \n        eps: small value preventing division by zero\n    \"\"\"\n    if len(scores) &lt; 3:\n        return Nearest()(targets, scores)\n\n    targets, scores = np_coerce(targets, scores)\n\n    scores = scores**0.5\n\n    scores = scores + eps\n    assert np.min(scores) &gt; 0\n\n    # largest scores -&gt; 0 weight\n    # zero score -&gt; inf weight\n    # zero first/second derivative at largest score\n    mx = np.max(scores, 0)\n    # weights = 1/scores + (-3*mx*mx + 3*mx*scores - scores*scores)/(mx**3)\n    # weights = 1/scores + (-3*mx*mx + (3*mx - scores)*scores)/(mx**3)\n    s_m = scores/mx\n    weights = 1/scores + ((3-s_m)*s_m - 3)/mx \n\n    weights = weights + eps/mx\n    weights = weights / weights.sum(0)\n\n    result = np.transpose((\n        np.transpose(targets)*np.transpose(weights)).sum(-1))\n\n    return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Softmax","title":"<code>Softmax</code>","text":"<p>             Bases: <code>Interpolate</code></p> <p>Like <code>Mean</code>, but weighted toward the nearer neighbors.</p> <p>when <code>k</code> is small, has discontinuities when temp is large, acts more like <code>Mean</code>. -&gt; tends to get 'washed out' for larger <code>k</code> / larger temp</p> <p>when temp is small, acts more like <code>Nearest</code> (voronoi cells).</p> <p>Scale-equivariant; the scale of inputs interacts with the <code>temp</code> parameter.  If input data is scaled by a factor <code>s</code>, scale <code>temp</code> by <code>s</code> to compensate.</p> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>class Softmax(Interpolate):\n    \"\"\"\n    Like `Mean`, but weighted toward the nearer neighbors.\n\n    when `k` is small, has discontinuities\n    when temp is large, acts more like `Mean`.\n    -&gt; tends to get 'washed out' for larger `k` / larger temp\n\n    when temp is small, acts more like `Nearest` (voronoi cells).\n\n    Scale-equivariant; the scale of inputs interacts with the `temp` parameter. \n    If input data is scaled by a factor `s`, scale `temp` by `s` to compensate.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, targets:List[Output], scores:List[float], temp:float=0.25):\n        \"\"\"\n        Args:\n            targets: size [K x ...batch dims... x ...output_dims...] \n            scores: size [K x ...batch dims...] \n            temp: temperature of softmax\n        \"\"\"\n        scores = scores**0.5\n\n        targets, scores = np_coerce(targets, scores)\n        # print(targets.shape, scores.shape)\n\n        if temp==0:\n            result = Nearest()(targets, scores)\n        else:\n            centered = scores - np.min(scores, 0) # for numerical precision\n            logits = np.maximum(-centered/temp, -30)\n            # print(f'{logits=}')\n            weights = np.exp(logits)\n            # print(f'{weights=}')\n            weights /= weights.sum(0)\n            # print(f'{weights=}')\n            result = np.transpose((\n                np.transpose(targets)*np.transpose(weights)).sum(-1))\n        # print(f'{result=}')\n        return result\n</code></pre>"},{"location":"reference/anguilla/interpolate/#anguilla.interpolate.Softmax.__call__","title":"<code>__call__(targets, scores, temp=0.25)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>targets</code> <code>List[Output]</code> <p>size [K x ...batch dims... x ...output_dims...] </p> required <code>scores</code> <code>List[float]</code> <p>size [K x ...batch dims...] </p> required <code>temp</code> <code>float</code> <p>temperature of softmax</p> <code>0.25</code> Source code in <code>src/anguilla/interpolate.py</code> <pre><code>def __call__(self, targets:List[Output], scores:List[float], temp:float=0.25):\n    \"\"\"\n    Args:\n        targets: size [K x ...batch dims... x ...output_dims...] \n        scores: size [K x ...batch dims...] \n        temp: temperature of softmax\n    \"\"\"\n    scores = scores**0.5\n\n    targets, scores = np_coerce(targets, scores)\n    # print(targets.shape, scores.shape)\n\n    if temp==0:\n        result = Nearest()(targets, scores)\n    else:\n        centered = scores - np.min(scores, 0) # for numerical precision\n        logits = np.maximum(-centered/temp, -30)\n        # print(f'{logits=}')\n        weights = np.exp(logits)\n        # print(f'{weights=}')\n        weights /= weights.sum(0)\n        # print(f'{weights=}')\n        result = np.transpose((\n            np.transpose(targets)*np.transpose(weights)).sum(-1))\n    # print(f'{result=}')\n    return result\n</code></pre>"},{"location":"reference/anguilla/nnsearch/","title":"Nnsearch","text":""},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.Index","title":"<code>Index</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> <p>base Index class. currently no function besides typing, warning of unimplemented features.</p> <p>Subclasses of Index implement nearest neighbor search with different cababilities and performance tradeoffs.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class Index(JSONSerializable):\n    \"\"\"\n    base Index class.\n    currently no function besides typing, warning of unimplemented features.\n\n    Subclasses of Index implement nearest neighbor search with different\n    cababilities and performance tradeoffs.\n    \"\"\"\n    def __init__(self, k=10, **kw):\n        super().__init__(k=k, **kw)\n        self.default_k = k\n        self.is_batched = False\n\n    def add(self, \n            zs:List[Feature], ws:List[Feature], ids:Optional[List[PairID]]=None\n        ) -&gt; List[PairID]:\n        raise NotImplementedError\n    def remove(self, ids:List[PairID]) -&gt; List[PairID]:\n        raise NotImplementedError\n    def get(self, ids:PairID) -&gt; IOPair:\n        \"\"\"not batched (mainly for testing purposes)\"\"\"\n        raise NotImplementedError\n    def search(self, zs:List[Feature], k:int) -&gt; SearchResult:\n        raise NotImplementedError\n    def reset(self):\n        raise NotImplementedError\n    @property\n    def ids(self):\n        raise NotImplementedError\n\n    def __len__(self):\n        return len(self.ids)\n\n    def __iter__(self):\n        \"\"\"iterate over IDs in the index\"\"\"\n        return iter(self.ids)\n\n    def items(self) -&gt; Generator[Tuple[PairID, IOPair], None, None]:\n        \"\"\"iterate over (ID, (Input, Output))\"\"\"\n        def iterator():\n            for i in self.ids:\n                yield i, self.get(i)\n        return iterator()\n\n    def distance(self, a:Feature, b:Feature) -&gt; float:\n        \"\"\"compute distance between two features\"\"\"\n        return self.metric(a, b)\n\n    def remove_near(self, zs:List[Feature], k:int=None) -&gt; PairIDs:\n        \"\"\"\n        Remove point(s) from the index by proximity.\n        Use k=1 to remove a single point.\n\n        Args:\n            zs: batch of query input features\n            k: number of nearest neighbors to each query point to remove\n                (defaults to index default k)\n        \"\"\"\n        zs, = np_coerce(zs)\n        assert zs.ndim==2, zs.shape\n\n        k = k or self.default_k\n\n        _, _, ids, _ = self.search(\n            zs, k, return_inputs=False, return_outputs=False, return_ids=True)\n\n        ids = set(ids.ravel())\n        return self.remove(ids)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.Index.__iter__","title":"<code>__iter__()</code>","text":"<p>iterate over IDs in the index</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __iter__(self):\n    \"\"\"iterate over IDs in the index\"\"\"\n    return iter(self.ids)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.Index.distance","title":"<code>distance(a, b)</code>","text":"<p>compute distance between two features</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def distance(self, a:Feature, b:Feature) -&gt; float:\n    \"\"\"compute distance between two features\"\"\"\n    return self.metric(a, b)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.Index.get","title":"<code>get(ids)</code>","text":"<p>not batched (mainly for testing purposes)</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def get(self, ids:PairID) -&gt; IOPair:\n    \"\"\"not batched (mainly for testing purposes)\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.Index.items","title":"<code>items()</code>","text":"<p>iterate over (ID, (Input, Output))</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def items(self) -&gt; Generator[Tuple[PairID, IOPair], None, None]:\n    \"\"\"iterate over (ID, (Input, Output))\"\"\"\n    def iterator():\n        for i in self.ids:\n            yield i, self.get(i)\n    return iterator()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.Index.remove_near","title":"<code>remove_near(zs, k=None)</code>","text":"<p>Remove point(s) from the index by proximity. Use k=1 to remove a single point.</p> <p>Parameters:</p> Name Type Description Default <code>zs</code> <code>List[Feature]</code> <p>batch of query input features</p> required <code>k</code> <code>int</code> <p>number of nearest neighbors to each query point to remove (defaults to index default k)</p> <code>None</code> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove_near(self, zs:List[Feature], k:int=None) -&gt; PairIDs:\n    \"\"\"\n    Remove point(s) from the index by proximity.\n    Use k=1 to remove a single point.\n\n    Args:\n        zs: batch of query input features\n        k: number of nearest neighbors to each query point to remove\n            (defaults to index default k)\n    \"\"\"\n    zs, = np_coerce(zs)\n    assert zs.ndim==2, zs.shape\n\n    k = k or self.default_k\n\n    _, _, ids, _ = self.search(\n        zs, k, return_inputs=False, return_outputs=False, return_ids=True)\n\n    ids = set(ids.ravel())\n    return self.remove(ids)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute","title":"<code>IndexBrute</code>","text":"<p>             Bases: <code>Index</code></p> <p>Optimized for simplicity and flexibility, may not scale to large datasets.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class IndexBrute(Index):\n    \"\"\"\n    Optimized for simplicity and flexibility,\n    may not scale to large datasets.\n    \"\"\"\n    def __init__(self, d:Tuple[int, int]=None, metric:Callable=None, **kw):\n        \"\"\"\n        Args:\n            d: optional, dimension of (input, output) features\n            metric: distance metric, default to squared euclidean\n        \"\"\"\n        if metric is None:\n            metric = sqL2()\n\n        super().__init__(d=d, metric=metric, **kw)\n        self.d = d\n        self.metric = metric\n\n        self.reset()\n\n    def add(self, \n            zs:List[Feature], \n            ws:List[Feature], \n            ids:Optional[List[PairID]]=None\n            ) -&gt; PairID:\n        \"\"\"add a new feature, return its ID.\n        Args:\n            feature: the feature to add\n            id: if not supplied, generate a new ID;\n                otherwise, use the supplied id.\n                supply an existing id to replace.\n        \"\"\"\n        if ids is None:\n            ids = it.repeat(None)\n        added_ids = []\n        for z,w,i in zip(zs, ws, ids):\n            if i is None:\n                i = max(self.z_data, default=-1) + 1\n            self.z_data[i] = z\n            self.w_data[i] = w\n            added_ids.append(i)\n        return added_ids\n\n    def remove(self, ids:List[PairID]):\n        \"\"\"remove points by ID\"\"\"\n        removed_ids = []\n        for i in ids:\n            del self.z_data[i]\n            if i in (self.w_data):\n                del self.w_data[i]\n                removed_ids.append(i)\n            else:\n                print(f'WARNING: anguilla: no point {i} in index')\n        return removed_ids\n\n    def get(self, i:List[PairID]) -&gt; Tuple[List[Feature], List[Feature]]:\n        \"\"\"get a pair by ID\"\"\"\n        if i in self.z_data:\n            return self.z_data[i], self.w_data[i]\n        else:\n           return None\n\n    def search(self, \n            zs:Feature, k:int=None,\n            return_inputs=True,\n            return_outputs=True, \n            return_ids=True\n        ) -&gt; SearchResult:\n        \"\"\"get feature(s) and IDs by proximity\"\"\"\n        k = k or self.default_k\n\n        zs_batch = [] if return_inputs else None\n        ws_batch = [] if return_outputs else None\n        ids_batch = [] if return_ids else None\n        scores_batch = []\n\n        for z in zs:\n            dist_id = sorted((self.metric(z, v),k) for k,v in self.z_data.items())\n\n            scores, ids = zip(*dist_id[:k])\n\n            if return_inputs:\n                zs_batch.append([self.z_data[i] for i in ids])\n            if return_outputs:\n                ws_batch.append([self.w_data[i] for i in ids])\n            if return_ids:\n                ids_batch.append(ids)\n\n            scores_batch.append(scores)\n\n        return SearchResult(\n            np.array(zs_batch),\n            np.array(ws_batch), \n            np.array(ids_batch), \n            np.array(scores_batch))\n\n    def reset(self):\n        self.z_data:Dict[PairID, Feature] = {}\n        self.w_data:Dict[PairID, Feature] = {}\n\n    @property\n    def ids(self):\n        return self.z_data.keys()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.__init__","title":"<code>__init__(d=None, metric=None, **kw)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>d</code> <code>Tuple[int, int]</code> <p>optional, dimension of (input, output) features</p> <code>None</code> <code>metric</code> <code>Callable</code> <p>distance metric, default to squared euclidean</p> <code>None</code> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __init__(self, d:Tuple[int, int]=None, metric:Callable=None, **kw):\n    \"\"\"\n    Args:\n        d: optional, dimension of (input, output) features\n        metric: distance metric, default to squared euclidean\n    \"\"\"\n    if metric is None:\n        metric = sqL2()\n\n    super().__init__(d=d, metric=metric, **kw)\n    self.d = d\n    self.metric = metric\n\n    self.reset()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.add","title":"<code>add(zs, ws, ids=None)</code>","text":"<p>add a new feature, return its ID. Args:     feature: the feature to add     id: if not supplied, generate a new ID;         otherwise, use the supplied id.         supply an existing id to replace.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def add(self, \n        zs:List[Feature], \n        ws:List[Feature], \n        ids:Optional[List[PairID]]=None\n        ) -&gt; PairID:\n    \"\"\"add a new feature, return its ID.\n    Args:\n        feature: the feature to add\n        id: if not supplied, generate a new ID;\n            otherwise, use the supplied id.\n            supply an existing id to replace.\n    \"\"\"\n    if ids is None:\n        ids = it.repeat(None)\n    added_ids = []\n    for z,w,i in zip(zs, ws, ids):\n        if i is None:\n            i = max(self.z_data, default=-1) + 1\n        self.z_data[i] = z\n        self.w_data[i] = w\n        added_ids.append(i)\n    return added_ids\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.get","title":"<code>get(i)</code>","text":"<p>get a pair by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def get(self, i:List[PairID]) -&gt; Tuple[List[Feature], List[Feature]]:\n    \"\"\"get a pair by ID\"\"\"\n    if i in self.z_data:\n        return self.z_data[i], self.w_data[i]\n    else:\n       return None\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.remove","title":"<code>remove(ids)</code>","text":"<p>remove points by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove(self, ids:List[PairID]):\n    \"\"\"remove points by ID\"\"\"\n    removed_ids = []\n    for i in ids:\n        del self.z_data[i]\n        if i in (self.w_data):\n            del self.w_data[i]\n            removed_ids.append(i)\n        else:\n            print(f'WARNING: anguilla: no point {i} in index')\n    return removed_ids\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexBrute.search","title":"<code>search(zs, k=None, return_inputs=True, return_outputs=True, return_ids=True)</code>","text":"<p>get feature(s) and IDs by proximity</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def search(self, \n        zs:Feature, k:int=None,\n        return_inputs=True,\n        return_outputs=True, \n        return_ids=True\n    ) -&gt; SearchResult:\n    \"\"\"get feature(s) and IDs by proximity\"\"\"\n    k = k or self.default_k\n\n    zs_batch = [] if return_inputs else None\n    ws_batch = [] if return_outputs else None\n    ids_batch = [] if return_ids else None\n    scores_batch = []\n\n    for z in zs:\n        dist_id = sorted((self.metric(z, v),k) for k,v in self.z_data.items())\n\n        scores, ids = zip(*dist_id[:k])\n\n        if return_inputs:\n            zs_batch.append([self.z_data[i] for i in ids])\n        if return_outputs:\n            ws_batch.append([self.w_data[i] for i in ids])\n        if return_ids:\n            ids_batch.append(ids)\n\n        scores_batch.append(scores)\n\n    return SearchResult(\n        np.array(zs_batch),\n        np.array(ws_batch), \n        np.array(ids_batch), \n        np.array(scores_batch))\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast","title":"<code>IndexFast</code>","text":"<p>             Bases: <code>Index</code></p> <p>Optimized for fast <code>search</code> on large vectors / datasets. Only L2 distance supported.  <code>remove</code> may be slow.</p> <p>This is currently a wrapper around <code>faiss.FlatIndexL2</code> which provides stable ids when using <code>remove</code>. In the future could support dot product and/or approximate search indices.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class IndexFast(Index):\n    \"\"\"\n    Optimized for fast `search` on large vectors / datasets.\n    Only L2 distance supported. \n    `remove` may be slow.\n\n    This is currently a wrapper around `faiss.FlatIndexL2` which provides stable ids when using `remove`.\n    In the future could support dot product and/or approximate search indices.\n    \"\"\"\n    def __init__(self, \n        d:Optional[Tuple[int,int]]=None, \n        metric:Callable=sqL2, \n        k=10):\n        \"\"\"\n        Args:\n            d: dimensions of (input, output)\n            metric:currently must be instance of `sqL2`\n        \"\"\"\n        super().__init__(d=d, metric=metric, k=k)\n        self.is_batched = True # `search` supports batching\n\n        if isinstance(metric, type) and issubclass(metric, Metric):\n            self.metric = metric()\n        else:\n            self.metric = metric\n\n        self.z_index = None\n        self.w_index = None\n        if d is not None:\n            self.init(d)\n\n    def init(self, d):\n        d_in, d_out = d\n        if isinstance(self.metric, sqL2):\n            self.z_index = IndexFlatL2(d_in)\n            self.w_index = IndexFlatL2(d_out)\n        else:\n            raise ValueError(\"\"\"IndexFast supports only sqL2 metric\"\"\")\n        self.reset()\n\n    @property\n    def d_in(self):\n        return self.z_index.d\n    @property\n    def d_out(self):\n        return self.w_index.d\n\n    def add(self, zs:Feature, ws:Feature, ids:Optional[PairID]=None):\n        \"\"\"add a new feature, return its ID.\n        Args:\n            zs: batch of input features to add\n            ws: batch of output features to add\n            ids: if not supplied, generate new IDs;\n                otherwise, use the supplied ids.\n                already existing ids will be replaced.\n        \"\"\"\n        zs, ws, ids = np_coerce(zs, ws, ids)\n        assert zs.ndim==2, zs.shape\n        assert ws.ndim==2, ws.shape\n        assert ids is None or ids.ndim==1, ids.shape\n\n        if self.z_index is None:\n            self.init((zs.shape[-1], ws.shape[-1]))\n\n        zs = zs.astype(np.float32)\n        ws = ws.astype(np.float32)\n\n        if ids is None:\n            # no ids supplied case\n            # generate new unique ids\n            n = max(self.id_to_idx, default=-1) + 1\n            ids = list(range(n, n+len(zs)))\n        else:\n            # remove any existing ids\n            self.remove([i for i in ids if i in self.id_to_idx])\n\n        self.z_index.add(zs)\n        self.w_index.add(ws)\n\n        n = self.z_index.ntotal\n        idx = np.arange(n - len(zs), n)\n\n        # map external ID to/from faiss index\n        for id_ext, idx_int in zip(ids, idx):\n            self.id_to_idx[id_ext] = idx_int\n            self.idx_to_id[idx_int] = id_ext\n\n        return ids\n\n    def remove(self, ids:PairIDs):\n        \"\"\"remove points by ID\"\"\"\n        removed_ids = []\n        for i in ids:\n            if i not in self.id_to_idx:\n                print(f'WARNING: anguilla: no point with ID {i} in index')\n                continue\n            removed_ids.append(i)\n            idx = self.id_to_idx[i]\n            del self.id_to_idx[i]\n            del self.idx_to_id[idx]\n            idx = np.array(idx)[None]\n            self.z_index.remove_ids(idx)\n            self.w_index.remove_ids(idx)\n            # faiss shifts its internal index to stay dense\n            self.id_to_idx = {\n                k:(v-1 if v &gt; idx else v) for k,v in self.id_to_idx.items()}\n            self.idx_to_id = {\n                (k-1 if k &gt; idx else k):v for k,v in self.idx_to_id.items()}\n        return removed_ids\n\n    def get(self, i:PairID) -&gt; Tuple[Feature, Feature]:\n        \"\"\"get a feature pair by ID\"\"\"\n        if self.z_index is None or i not in self.id_to_idx:\n            print(f'WARNING: anguilla: no point with ID {i} in index')\n            return None\n        else:\n            idx = int(self.id_to_idx[i])\n            return (\n                self.z_index.reconstruct(idx), \n                self.w_index.reconstruct(idx))\n\n    def search(self, \n            z:List[Feature], k:int=None, \n            return_inputs=True,\n            return_outputs=True, \n            return_ids=True\n            ) -&gt; SearchResult:\n        \"\"\"get outputs(s), distances, and IDs by proximity\n\n        Returns:\n            zs: [batch, k, input feature]\n            ws: [batch, k, output feature]\n            ids: [batch, k]\n            scores: [batch, k]\n        \"\"\"\n        k = k or self.default_k\n        z, = np_coerce(z)\n        # if z.ndim==1:\n            # z = z[None]\n            # batch = False\n        # elif z.ndim==2:\n            # batch = True\n        # else:\n            # raise ValueError\n        if z.ndim!=2: raise ValueError\n        # print(f'{batch=}', z.ndim)\n        z = z.astype(np.float32) \n\n        assert isinstance(z, np.ndarray)\n        assert z.dtype == np.float32\n\n        # nearest neighbor search\n        scores, idxs = self.z_index.search(z, k)\n        # print(idxs)\n\n        # remove -1 ids\n        # assuming pattern of missing is same across batch\n        # should be, since only reason for missing is &lt;k data points\n        b = [i&gt;=0 for i in idxs[0]] \n        scores, idxs = scores[:,b], idxs[:,b]\n\n        if return_inputs:    \n            zs = self.z_index.reconstruct_batch(\n                idxs.ravel()).reshape([*idxs.shape, -1])\n        else:\n            zs = None #if batch else [None]\n\n        if return_outputs:    \n            ws = self.w_index.reconstruct_batch(\n                idxs.ravel()).reshape([*idxs.shape, -1])\n        else:\n            ws = None #if batch else [None]\n\n        # map back to ids\n        if return_ids:\n            ids = np.array([[self.idx_to_id[i] for i in idx] for idx in idxs])\n        else:\n            ids = None #if batch else [None]\n\n        # if not batch:\n            # remove batch dim\n            # zs, ws, scores, ids = zs[0], ws[0], scores[0], ids[0]\n\n        return SearchResult(zs, ws, ids, scores)\n\n    def reset(self):\n        if self.z_index is not None:\n            pass\n            self.z_index.reset()\n            self.w_index.reset()\n        self.idx_to_id:Dict[int, PairID] = {}\n        self.id_to_idx:Dict[PairID, int] = {}\n\n    @property\n    def ids(self):\n        return self.id_to_idx.keys()\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.__init__","title":"<code>__init__(d=None, metric=sqL2, k=10)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>d</code> <code>Optional[Tuple[int, int]]</code> <p>dimensions of (input, output)</p> <code>None</code> <code>metric</code> <code>Callable</code> <p>currently must be instance of <code>sqL2</code></p> <code>sqL2</code> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def __init__(self, \n    d:Optional[Tuple[int,int]]=None, \n    metric:Callable=sqL2, \n    k=10):\n    \"\"\"\n    Args:\n        d: dimensions of (input, output)\n        metric:currently must be instance of `sqL2`\n    \"\"\"\n    super().__init__(d=d, metric=metric, k=k)\n    self.is_batched = True # `search` supports batching\n\n    if isinstance(metric, type) and issubclass(metric, Metric):\n        self.metric = metric()\n    else:\n        self.metric = metric\n\n    self.z_index = None\n    self.w_index = None\n    if d is not None:\n        self.init(d)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.add","title":"<code>add(zs, ws, ids=None)</code>","text":"<p>add a new feature, return its ID. Args:     zs: batch of input features to add     ws: batch of output features to add     ids: if not supplied, generate new IDs;         otherwise, use the supplied ids.         already existing ids will be replaced.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def add(self, zs:Feature, ws:Feature, ids:Optional[PairID]=None):\n    \"\"\"add a new feature, return its ID.\n    Args:\n        zs: batch of input features to add\n        ws: batch of output features to add\n        ids: if not supplied, generate new IDs;\n            otherwise, use the supplied ids.\n            already existing ids will be replaced.\n    \"\"\"\n    zs, ws, ids = np_coerce(zs, ws, ids)\n    assert zs.ndim==2, zs.shape\n    assert ws.ndim==2, ws.shape\n    assert ids is None or ids.ndim==1, ids.shape\n\n    if self.z_index is None:\n        self.init((zs.shape[-1], ws.shape[-1]))\n\n    zs = zs.astype(np.float32)\n    ws = ws.astype(np.float32)\n\n    if ids is None:\n        # no ids supplied case\n        # generate new unique ids\n        n = max(self.id_to_idx, default=-1) + 1\n        ids = list(range(n, n+len(zs)))\n    else:\n        # remove any existing ids\n        self.remove([i for i in ids if i in self.id_to_idx])\n\n    self.z_index.add(zs)\n    self.w_index.add(ws)\n\n    n = self.z_index.ntotal\n    idx = np.arange(n - len(zs), n)\n\n    # map external ID to/from faiss index\n    for id_ext, idx_int in zip(ids, idx):\n        self.id_to_idx[id_ext] = idx_int\n        self.idx_to_id[idx_int] = id_ext\n\n    return ids\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.get","title":"<code>get(i)</code>","text":"<p>get a feature pair by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def get(self, i:PairID) -&gt; Tuple[Feature, Feature]:\n    \"\"\"get a feature pair by ID\"\"\"\n    if self.z_index is None or i not in self.id_to_idx:\n        print(f'WARNING: anguilla: no point with ID {i} in index')\n        return None\n    else:\n        idx = int(self.id_to_idx[i])\n        return (\n            self.z_index.reconstruct(idx), \n            self.w_index.reconstruct(idx))\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.remove","title":"<code>remove(ids)</code>","text":"<p>remove points by ID</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def remove(self, ids:PairIDs):\n    \"\"\"remove points by ID\"\"\"\n    removed_ids = []\n    for i in ids:\n        if i not in self.id_to_idx:\n            print(f'WARNING: anguilla: no point with ID {i} in index')\n            continue\n        removed_ids.append(i)\n        idx = self.id_to_idx[i]\n        del self.id_to_idx[i]\n        del self.idx_to_id[idx]\n        idx = np.array(idx)[None]\n        self.z_index.remove_ids(idx)\n        self.w_index.remove_ids(idx)\n        # faiss shifts its internal index to stay dense\n        self.id_to_idx = {\n            k:(v-1 if v &gt; idx else v) for k,v in self.id_to_idx.items()}\n        self.idx_to_id = {\n            (k-1 if k &gt; idx else k):v for k,v in self.idx_to_id.items()}\n    return removed_ids\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.IndexFast.search","title":"<code>search(z, k=None, return_inputs=True, return_outputs=True, return_ids=True)</code>","text":"<p>get outputs(s), distances, and IDs by proximity</p> <p>Returns:</p> Name Type Description <code>zs</code> <code>SearchResult</code> <p>[batch, k, input feature]</p> <code>ws</code> <code>SearchResult</code> <p>[batch, k, output feature]</p> <code>ids</code> <code>SearchResult</code> <p>[batch, k]</p> <code>scores</code> <code>SearchResult</code> <p>[batch, k]</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>def search(self, \n        z:List[Feature], k:int=None, \n        return_inputs=True,\n        return_outputs=True, \n        return_ids=True\n        ) -&gt; SearchResult:\n    \"\"\"get outputs(s), distances, and IDs by proximity\n\n    Returns:\n        zs: [batch, k, input feature]\n        ws: [batch, k, output feature]\n        ids: [batch, k]\n        scores: [batch, k]\n    \"\"\"\n    k = k or self.default_k\n    z, = np_coerce(z)\n    # if z.ndim==1:\n        # z = z[None]\n        # batch = False\n    # elif z.ndim==2:\n        # batch = True\n    # else:\n        # raise ValueError\n    if z.ndim!=2: raise ValueError\n    # print(f'{batch=}', z.ndim)\n    z = z.astype(np.float32) \n\n    assert isinstance(z, np.ndarray)\n    assert z.dtype == np.float32\n\n    # nearest neighbor search\n    scores, idxs = self.z_index.search(z, k)\n    # print(idxs)\n\n    # remove -1 ids\n    # assuming pattern of missing is same across batch\n    # should be, since only reason for missing is &lt;k data points\n    b = [i&gt;=0 for i in idxs[0]] \n    scores, idxs = scores[:,b], idxs[:,b]\n\n    if return_inputs:    \n        zs = self.z_index.reconstruct_batch(\n            idxs.ravel()).reshape([*idxs.shape, -1])\n    else:\n        zs = None #if batch else [None]\n\n    if return_outputs:    \n        ws = self.w_index.reconstruct_batch(\n            idxs.ravel()).reshape([*idxs.shape, -1])\n    else:\n        ws = None #if batch else [None]\n\n    # map back to ids\n    if return_ids:\n        ids = np.array([[self.idx_to_id[i] for i in idx] for idx in idxs])\n    else:\n        ids = None #if batch else [None]\n\n    # if not batch:\n        # remove batch dim\n        # zs, ws, scores, ids = zs[0], ws[0], scores[0], ids[0]\n\n    return SearchResult(zs, ws, ids, scores)\n</code></pre>"},{"location":"reference/anguilla/nnsearch/#anguilla.nnsearch.Metric","title":"<code>Metric</code>","text":"<p>             Bases: <code>JSONSerializable</code></p> <p>define a distance between two points.  Relative distances will be used to find nearest neighbors, and the distances to neighbors will be passed to <code>Interpolate</code>.</p> Source code in <code>src/anguilla/nnsearch.py</code> <pre><code>class Metric(JSONSerializable):\n    \"\"\"\n    define a distance between two points. \n    Relative distances will be used to find nearest neighbors,\n    and the distances to neighbors will be passed to `Interpolate`.\n    \"\"\"\n    def __call__(self, a, b):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/anguilla/serialize/","title":"Serialize","text":""},{"location":"reference/anguilla/serialize/#anguilla.serialize.JSONSerializable","title":"<code>JSONSerializable</code>","text":"<p>JSON serialization for Python classes. Saves keyword arguments at construction, and also any state returned by the <code>save_state</code> method. Does not attempt to serialize code or any other attributes.</p> <p>to make class a serializable, subclass JSONSerializable,  and in the constructor use e.g. <code>super().__init__(a=0, b=1 ...)</code> with any keyword args which should be serialized.</p> <p>override <code>save_state</code> and <code>load_state</code> to handle any mutable state.</p> <p>Constructor args and return values of <code>save_state</code> can be other JSONSerializable objects, or any types which are already serializable by the standard library <code>json</code> module.</p> Source code in <code>src/anguilla/serialize.py</code> <pre><code>class JSONSerializable:\n    \"\"\"JSON serialization for Python classes.\n    Saves keyword arguments at construction,\n    and also any state returned by the `save_state` method.\n    Does *not* attempt to serialize code or any other attributes.\n\n    to make class a serializable, subclass JSONSerializable, \n    and in the constructor use e.g. `super().__init__(a=0, b=1 ...)`\n    with any keyword args which should be serialized.\n\n    override `save_state` and `load_state` to handle any mutable state.\n\n    Constructor args and return values of `save_state` can be other JSONSerializable objects, or any types which are already serializable by\n    the standard library `json` module.\n    \"\"\"\n    def __init__(self, **kw):\n        self._kw = deepcopy(kw)\n        self._kw['__inst__'] = '.'.join((\n            self.__class__.__module__,\n            self.__class__.__name__))\n\n    def _store(self):\n        return {'__state__': self.save_state(), **self._kw}\n\n    def save_state(self):\n        \"\"\"return object state in JSON serializable form\"\"\"\n        return None\n\n    def load_state(self, state):\n        \"\"\"restore from de-serialized state\"\"\"\n        pass\n</code></pre>"},{"location":"reference/anguilla/serialize/#anguilla.serialize.JSONSerializable.load_state","title":"<code>load_state(state)</code>","text":"<p>restore from de-serialized state</p> Source code in <code>src/anguilla/serialize.py</code> <pre><code>def load_state(self, state):\n    \"\"\"restore from de-serialized state\"\"\"\n    pass\n</code></pre>"},{"location":"reference/anguilla/serialize/#anguilla.serialize.JSONSerializable.save_state","title":"<code>save_state()</code>","text":"<p>return object state in JSON serializable form</p> Source code in <code>src/anguilla/serialize.py</code> <pre><code>def save_state(self):\n    \"\"\"return object state in JSON serializable form\"\"\"\n    return None\n</code></pre>"},{"location":"reference/anguilla/serialize/#anguilla.serialize.get_cls","title":"<code>get_cls(s)</code>","text":"<p>convert a type name to a type, importing dependencies as needed</p> <p>e.g. \"somepackage.submodule.SomeClass\" -&gt; SomeClass </p> <p>this works by doing: import somepackage import somepackage.submodule.SomeClass eval(\"somepackage.submodule.SomeClass\")</p> <p>this should work in most cases, but could possibly break if the package containing the type has a weird structure.</p> <p>In cases where dependencies rename / reorganize their types, breaking old anguilla files, any translation of type names can be done here.</p> Source code in <code>src/anguilla/serialize.py</code> <pre><code>def get_cls(s):\n    \"\"\"convert a type name to a type, importing dependencies as needed\n\n    e.g. \"somepackage.submodule.SomeClass\" -&gt; SomeClass \n\n    this works by doing:\n    import somepackage\n    import somepackage.submodule.SomeClass\n    eval(\"somepackage.submodule.SomeClass\")\n\n    this should work in most cases, but could possibly break if the package containing the type has a weird structure.\n\n    In cases where dependencies rename / reorganize their types, breaking old\n    anguilla files, any translation of type names can be done here.\n    \"\"\"\n\n    # sanitize inputs\n    assert all(item.isidentifier() for item in s.split('.')), s\n    parts = s.split('.')\n\n    ### backward compat translations ###\n    if parts[0]=='iml': parts[0] = 'anguilla'\n\n    pkg = parts[0]\n    mod = '.'.join(parts[:-1])\n    # import top level package the type belongs to\n    exec(f'import {pkg}') \n    # import submodule the type is in\n    exec(f'import {mod}')\n    # convert string to type\n    return eval(s)\n</code></pre>"},{"location":"reference/anguilla/types/","title":"Types","text":""},{"location":"reference/anguilla/app/__init__/","title":"init","text":""},{"location":"reference/anguilla/app/server/","title":"Server","text":"Authors <p>Victor Shepardson Intelligent Instruments Lab 2023</p>"},{"location":"reference/anguilla/app/server/#anguilla.app.server.main","title":"<code>main(osc_port=8732, osc_return_port=None, osc_host='', verbose=1)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>osc_port</code> <code>int</code> <p>listen for OSC controls on this port</p> <code>8732</code> <code>osc_return_port</code> <code>Optional[int]</code> <p>if supplied, reply on a different port than osc_port</p> <code>None</code> <code>osc_host</code> <code>str</code> <p>leave this as empty string to get all traffic on the port</p> <code>''</code> <p>OSC Methods:</p> <pre><code>/anguilla/instance/config \"embed_input\" \"Identity\"\n    set input embedding to Identity (the default)\n/anguilla/instance/config \"embed_input\" \"ProjectAndSort\"\n    set input embedding to ProjectAndSort\n\n/anguilla/instance/config \"interpolate\" \"Smooth\"\n    set interpolator to Smooth (the default)\n/anguilla/instance/config \"interpolate\" \"Softmax\"\n    set interpolator to Softmax\n/anguilla/instance/config \"interpolate\" \"Ripple\"\n    set interpolator to Ripple\n\n/anguilla/instance/add \"input\" ... \"output\"... \n    add a point to the mapping\n\n/anguilla/instance/add_batch \"input\" &lt;json&gt; \"output\" &lt;json&gt; \n    add a batch of points to the mapping\n    each &lt;json&gt; is a JSON string: { \"shape\": [B, D], \"data\": [...] }\n    where B is the batch size and D is the input dimension,\n    and data is a list of numbers of length B*D.\n\n/anguilla/instance/remove id \n    remove a point from the mapping by ID\n\n/anguilla/instance/remove_near \"input\" ... [\"k\" k]\n    remove k points from the mapping by proximity\n    here you would replace '...' with a series of numbers\n    '[]' denotes optional parts of the message (not OSC lists)\n\n/anguilla/instance/map \"input\" ... [\"k\" k] [\"ripple\" r] [\"temp\" t]\n    map an input to an output using k neighbors\n    \"temp\" 1 &gt; t &gt; 0 when using Softmax interpolator\n    \"ripple\" r &gt; 0 when using Ripple interpolator\n\n/anguilla/instance/map_batch \"input\" &lt;json&gt; [\"k\" k] [\"ripple\" r] [\"temp\" t] \n    add a batch of points to the mapping\n    &lt;json&gt; is a JSON string: { \"shape\": [B, D], \"data\": [...] }\n    where B is the batch size and D is the input dimension,\n    and data is a list of numbers of length B*D.\n    the output is returned as JSON in the same format.\n\n/anguilla/instance/reset\n    remove all points\n/anguilla/instance/reset \"keep_near\" ... [\"k\" k]\n    remove all points except the k neighbors of \"keep_near\"\n\n/anguilla/instance/load path\n    load IML from file at `path`\n/anguilla/instance/save path\n    save IML to file at `path`\n\nreplace 'instance' with any string to address a unique IML instance.\n</code></pre> Source code in <code>src/anguilla/app/server.py</code> <pre><code>def main(\n    osc_port:int=8732,\n    osc_return_port:Optional[int]=None,\n    osc_host:str='',\n    verbose=1,\n    ):\n    \"\"\"\n    Args:\n        osc_port: listen for OSC controls on this port\n        osc_return_port: if supplied, reply on a different port than osc_port\n        osc_host: leave this as empty string to get all traffic on the port\n\n    OSC Methods:\n\n        /anguilla/instance/config \"embed_input\" \"Identity\"\n            set input embedding to Identity (the default)\n        /anguilla/instance/config \"embed_input\" \"ProjectAndSort\"\n            set input embedding to ProjectAndSort\n\n        /anguilla/instance/config \"interpolate\" \"Smooth\"\n            set interpolator to Smooth (the default)\n        /anguilla/instance/config \"interpolate\" \"Softmax\"\n            set interpolator to Softmax\n        /anguilla/instance/config \"interpolate\" \"Ripple\"\n            set interpolator to Ripple\n\n        /anguilla/instance/add \"input\" ... \"output\"... \n            add a point to the mapping\n\n        /anguilla/instance/add_batch \"input\" &lt;json&gt; \"output\" &lt;json&gt; \n            add a batch of points to the mapping\n            each &lt;json&gt; is a JSON string: { \"shape\": [B, D], \"data\": [...] }\n            where B is the batch size and D is the input dimension,\n            and data is a list of numbers of length B*D.\n\n        /anguilla/instance/remove id \n            remove a point from the mapping by ID\n\n        /anguilla/instance/remove_near \"input\" ... [\"k\" k]\n            remove k points from the mapping by proximity\n            here you would replace '...' with a series of numbers\n            '[]' denotes optional parts of the message (not OSC lists)\n\n        /anguilla/instance/map \"input\" ... [\"k\" k] [\"ripple\" r] [\"temp\" t]\n            map an input to an output using k neighbors\n            \"temp\" 1 &gt; t &gt; 0 when using Softmax interpolator\n            \"ripple\" r &gt; 0 when using Ripple interpolator\n\n        /anguilla/instance/map_batch \"input\" &lt;json&gt; [\"k\" k] [\"ripple\" r] [\"temp\" t] \n            add a batch of points to the mapping\n            &lt;json&gt; is a JSON string: { \"shape\": [B, D], \"data\": [...] }\n            where B is the batch size and D is the input dimension,\n            and data is a list of numbers of length B*D.\n            the output is returned as JSON in the same format. \n\n        /anguilla/instance/reset\n            remove all points\n        /anguilla/instance/reset \"keep_near\" ... [\"k\" k]\n            remove all points except the k neighbors of \"keep_near\"\n\n        /anguilla/instance/load path\n            load IML from file at `path`\n        /anguilla/instance/save path\n            save IML to file at `path`\n\n        replace 'instance' with any string to address a unique IML instance.\n    \"\"\"\n    osc = OSC(osc_host, osc_port, verbose=verbose)\n\n    if verbose:\n        print(main.__doc__)\n\n    instances = {}\n    configs = defaultdict(dict)\n\n    def get_instance(address, create=True):\n        key = get_handle(address)\n        if key not in instances:\n            if create:\n                print(f'{address} new IML object with handle \"{key}\" with config {configs[key]}')\n                instances[key] = IML(**configs[key])\n            else:\n                print(f'ERROR: {address}: no instance \"{key}\" exists')\n                return None\n        return instances[key]\n\n    @osc.handle\n    def _(address, *a):\n        print(address)\n\n    @osc.kwargs('/anguilla/*/config')\n    def _(address, **kw):\n        key = get_handle(address)\n        # print(k)\n        # TODO: validate input\n        configs[key].update(kw)\n        if verbose &gt; 0:\n            print(f'{configs=}') \n\n        '/return'+address, str(configs[key])\n\n    @osc.handle('/anguilla/*/add', return_port=osc_return_port)\n    def _(address, input:Splat[None], output:Splat[None], id:int=None):\n        iml = get_instance(address)\n        return '/return'+address, iml.add(input, output, id=id)\n\n    @osc.handle('/anguilla/*/add_batch', return_port=osc_return_port)\n    def _(address, inputs:NDArray, outputs:NDArray, ids:NDArray=None):\n        iml = get_instance(address)\n        ids = iml.add_batch(inputs, outputs, ids=ids)\n        return '/return'+address, *ids\n\n    @osc.handle('/anguilla/*/remove')\n    def _(address, id:int):\n        iml = get_instance(address, create=False)\n        if iml is not None:\n            iml.remove(id)\n\n    @osc.handle('/anguilla/*/remove_near')\n    def _(address, input:Splat[None], k:int=None):\n        iml = get_instance(address, create=False)\n        if iml is not None:\n            iml.remove_near(input, k=k)\n\n    @osc.handle('/anguilla/*/map', return_port=osc_return_port)\n    def _(address, input:Splat[None], k:int=None, **kw):\n        iml = get_instance(address, create=False)\n        if iml is not None:\n            return '/return'+address, *iml.map(input, k=k, **kw).tolist()\n        else:\n            print(f'ERROR: anguilla: call {address.replace(\"map\", \"add\")} at least once before {address}')\n\n    @osc.handle('/anguilla/*/map_batch', return_port=osc_return_port)\n    def _(address, inputs:NDArray, k:int=None, **kw):\n        iml = get_instance(address, create=False)\n        if iml is not None:        \n            return '/return'+address, ndarray_to_json(iml.map_batch(\n                inputs, k=k, **kw))\n        else:\n            print(f'ERROR: anguilla: call {address.replace(\"map\", \"add\")} at least once before {address}')\n\n    @osc.handle('/anguilla/*/reset')\n    def _(address, keep_near:Splat[None]=None, k:int=None):\n        iml = get_instance(address, create=False)\n        if iml is not None:\n            iml.reset(keep_near, k=k)\n\n    @osc.handle('/anguilla/*/load')\n    def _(address, path:str):\n        key = get_handle(address)\n\n        assert path.endswith('.json'), \\\n            f\"ERROR: anguilla {address}: path should end with .json\"\n\n        print(f'load IML object at \"{key}\" from {path}')\n        instances[key] = IML.load(path)\n\n    @osc.handle('/anguilla/*/save')\n    def _(address, path:str):\n        iml = get_instance(address, create=False)\n\n        assert path.endswith('.json'), \\\n            f\"ERROR: anguilla {address}: path should end with .json\"\n\n        if iml is not None:\n            print(f'saving IML object at \"{get_handle(address)}\" to {path}')\n            iml.save(path)\n\n    ## TODO: add load_all, save_all?\n\n    @osc.handle('/anguilla/*/seq_input', return_port=osc_return_port)\n    def _(address, input:Splat[None]):\n        iml = get_instance(address)\n        iml.seq_input(input)\n\n    @osc.handle('/anguilla/*/seq_output', return_port=osc_return_port)\n    def _(address, output:Splat[None]):\n        iml = get_instance(address)\n        iml.seq_output(output)\n\n    @osc.handle('/anguilla/*/seq_end', return_port=osc_return_port)\n    def _(address, n=100):\n        iml = get_instance(address)\n        return '/return'+address, iml.seq_end(n)\n\n    @osc.handle('/anguilla/*/seq_reset', return_port=osc_return_port)\n    def _(address):\n        iml = get_instance(address)\n        return '/return'+address, iml.seq_reset()\n</code></pre>"}]}